/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/extractmovie.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/extractmovie.ts":
/*!*****************************!*\
  !*** ./src/extractmovie.ts ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_download__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/download */ \"./src/helpers/download.ts\");\n/* harmony import */ var _helpers_detecttype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/detecttype */ \"./src/helpers/detecttype.ts\");\n/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings */ \"./src/settings.ts\");\n/* harmony import */ var _helpers_save__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers/save */ \"./src/helpers/save.ts\");\n\n\n\n\n(async () => {\n    const movie = await Object(_helpers_download__WEBPACK_IMPORTED_MODULE_0__[\"download\"])();\n    const media = {\n        type: Object(_helpers_detecttype__WEBPACK_IMPORTED_MODULE_1__[\"detectType\"])(movie),\n        data: movie,\n        name: document.title.split(_settings__WEBPACK_IMPORTED_MODULE_2__[\"VIDEO_TITLE_SAFIX\"])[0]\n    };\n    Object(_helpers_save__WEBPACK_IMPORTED_MODULE_3__[\"save\"])(media);\n})();\n\n\n//# sourceURL=webpack:///./src/extractmovie.ts?");

/***/ }),

/***/ "./src/helpers/detecttype.ts":
/*!***********************************!*\
  !*** ./src/helpers/detecttype.ts ***!
  \***********************************/
/*! exports provided: detectType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detectType\", function() { return detectType; });\n/* harmony import */ var _vendor_mp4_js_dist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/mp4.js/dist */ \"./vendor/mp4.js/dist/index.js\");\n/* harmony import */ var _vendor_mp4_js_dist__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vendor_mp4_js_dist__WEBPACK_IMPORTED_MODULE_0__);\n\nconst detectType = (movie) => {\n    var view = new _vendor_mp4_js_dist__WEBPACK_IMPORTED_MODULE_0__[\"Mp4\"].DataView2(movie);\n    if (view.getString(4, 4) === \"ftyp\") {\n        return \"mp4\";\n    }\n    else {\n        switch (view.getString(0, 3)) {\n            case \"FWS\":\n            case \"CWS\":\n                return \"swf\";\n            case \"FLV\":\n                return \"flv\";\n        }\n    }\n};\n\n\n//# sourceURL=webpack:///./src/helpers/detecttype.ts?");

/***/ }),

/***/ "./src/helpers/download.ts":
/*!*********************************!*\
  !*** ./src/helpers/download.ts ***!
  \*********************************/
/*! exports provided: download */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"download\", function() { return download; });\nconst container = document.createElement(\"div\");\ncontainer.style.position = \"fixed\";\ncontainer.style.right = \"0px\";\ncontainer.style.bottom = \"0px\";\ncontainer.style.width = \"240px\";\ncontainer.style.backgroundColor = \"#fff\";\ncontainer.style.zIndex = \"10000000000\";\ncontainer.style.transform = \"translateX(100%)\";\ncontainer.style.transition = \"transform 0.25s\";\ncontainer.style.boxShadow = \"0 0 5px rgba(0,0,0,.2)\";\nconst progressBar = document.createElement(\"div\");\nprogressBar.style.height = \"3px\";\nprogressBar.style.width = \"0%\";\nprogressBar.style.backgroundColor = \"rgb(90, 185, 241)\";\nconst messageBox = document.createElement(\"div\");\nmessageBox.style.width = \"100%\";\nmessageBox.style.padding = \"10px 5px\";\nmessageBox.style.fontSize = \"12px\";\nmessageBox.style.color = \"#494949\";\nconst closeBtn = document.createElement(\"div\");\ncloseBtn.textContent = \"Ã—\";\ncloseBtn.style.position = \"absolute\";\ncloseBtn.style.right = \"10px\";\ncloseBtn.style.bottom = \"5px\";\ncloseBtn.style.fontSize = \"20px\";\ncloseBtn.style.cursor = \"pointer\";\ncontainer.appendChild(progressBar);\ncontainer.appendChild(messageBox);\ndocument.body.appendChild(container);\nconst download = () => {\n    return new Promise((resolve, reject) => {\n        window.requestIdleCallback(async () => {\n            container.style.transform = \"translateX(0%)\";\n            const request = () => {\n                return new Promise((_, reject) => {\n                    const url = document.querySelector(\"#MainVideoPlayer video\").src;\n                    const xhr = new XMLHttpRequest();\n                    xhr.responseType = \"arraybuffer\";\n                    xhr.open(\"GET\", url);\n                    xhr.send();\n                    xhr.onprogress = e => {\n                        if (e.loaded === e.total)\n                            return;\n                        const r = Math.floor((e.loaded / e.total) * 100);\n                        progressBar.style.width = r + \"%\";\n                        messageBox.textContent = `Now Loading... ${r}%. Do not close!`;\n                    };\n                    xhr.onloadend = () => {\n                        if (200 <= xhr.status && xhr.status < 300) {\n                            const movie = new Uint8Array(xhr.response);\n                            progressBar.style.width = \"100%\";\n                            messageBox.textContent = \"Complete!\";\n                            resolve(movie);\n                            setTimeout(() => container.remove(), 2000);\n                        }\n                        else {\n                            reject(new Error(`Error: ${xhr.status}`));\n                        }\n                    };\n                });\n            };\n            for (let i = 3; i >= 0; i--) {\n                try {\n                    await request();\n                    return;\n                }\n                catch (e) {\n                    if (i === 0) {\n                        messageBox.textContent = e.message;\n                        container.appendChild(closeBtn);\n                        closeBtn.onclick = () => container.remove();\n                        reject();\n                    }\n                }\n            }\n        });\n    });\n};\n\n\n//# sourceURL=webpack:///./src/helpers/download.ts?");

/***/ }),

/***/ "./src/helpers/save.ts":
/*!*****************************!*\
  !*** ./src/helpers/save.ts ***!
  \*****************************/
/*! exports provided: save */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"save\", function() { return save; });\nconst save = (media) => {\n    const a = document.createElement(\"a\");\n    const e = document.createEvent(\"MouseEvent\");\n    const objUrl = URL.createObjectURL(new Blob([media.data]));\n    a.setAttribute(\"download\", media.name + \".\" + media.type);\n    a.setAttribute(\"href\", objUrl);\n    e.initEvent(\"click\", true, true);\n    a.dispatchEvent(e);\n    URL.revokeObjectURL(objUrl);\n};\n\n\n//# sourceURL=webpack:///./src/helpers/save.ts?");

/***/ }),

/***/ "./src/settings.ts":
/*!*************************!*\
  !*** ./src/settings.ts ***!
  \*************************/
/*! exports provided: VIDEO_TITLE_SAFIX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VIDEO_TITLE_SAFIX\", function() { return VIDEO_TITLE_SAFIX; });\nconst VIDEO_TITLE_SAFIX = decodeURIComponent(\"%20-%20%E3%83%8B%E3%82%B3%E3%83%8B%E3%82%B3%E5%8B%95%E7%94%BB\");\n\n\n//# sourceURL=webpack:///./src/settings.ts?");

/***/ }),

/***/ "./vendor/mp4.js/dist/bitreader.js":
/*!*****************************************!*\
  !*** ./vendor/mp4.js/dist/bitreader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataview_1 = __webpack_require__(/*! ./dataview */ \"./vendor/mp4.js/dist/dataview.js\");\n// prettier-ignore\nconst BIT_MASKS = [\n    0x00000000,\n    0x00000001, 0x00000003, 0x00000007, 0x0000000F,\n    0x0000001F, 0x0000003F, 0x0000007F, 0x000000FF,\n    0x000001FF, 0x000003FF, 0x000007FF, 0x00000FFF,\n    0x00001FFF, 0x00003FFF, 0x00007FFF, 0x0000FFFF,\n    0x0001FFFF, 0x0003FFFF, 0x0007FFFF, 0x000FFFFF,\n    0x001FFFFF, 0x003FFFFF, 0x007FFFFF, 0x00FFFFFF,\n    0x01FFFFFF //, 0x03FFFFFF, 0x07FFFFFF, 0x0FFFFFFF,\n    // 0x1FFFFFFF, 0x3FFFFFFF, 0x7FFFFFFF, 0xFFFFFFFF\n];\nconst POW25 = Math.pow(2, 25);\nconst POW32 = Math.pow(2, 32);\nclass BitReader {\n    constructor(bytes, littleEndian = false) {\n        this.bytes = bytes;\n        this.littleEndian = littleEndian;\n        this.bitOffset = 0;\n        this.view = new dataview_1.DataView2(bytes);\n    }\n    readBits(n) {\n        if (n <= 0)\n            throw new Error();\n        let tmp;\n        let needBytes;\n        let m;\n        let ret = 0;\n        const max = 25;\n        while (n > 0) {\n            m = n > max ? max : n;\n            ret *= POW25;\n            needBytes = Math.ceil(((this.bitOffset % 8) + m) / 8);\n            switch (needBytes) {\n                case 1:\n                    tmp = this.view.getUint8(this.byteOffset);\n                    break;\n                case 2:\n                    tmp = this.view.getUint16(this.byteOffset);\n                    break;\n                case 3:\n                    tmp = this.view.getUint24(this.byteOffset);\n                    break;\n                case 4:\n                    tmp = this.view.getUint32(this.byteOffset);\n                    break;\n            }\n            ret +=\n                (tmp >>> (needBytes * 8 - ((this.bitOffset % 8) + m))) & BIT_MASKS[m];\n            this.skipBits(m);\n            n -= m;\n        }\n        return ret;\n    }\n    readUint8() {\n        const ret = this.view.getUint8(this.byteOffset);\n        this.skipBytes(1);\n        return ret;\n    }\n    readInt8() {\n        const ret = this.view.getInt8(this.byteOffset);\n        this.skipBytes(1);\n        return ret;\n    }\n    readUint16() {\n        const ret = this.view.getUint16(this.byteOffset, this.littleEndian);\n        this.skipBytes(2);\n        return ret;\n    }\n    readInt16() {\n        const ret = this.view.getInt16(this.byteOffset, this.littleEndian);\n        this.skipBytes(2);\n        return ret;\n    }\n    readUint24() {\n        const ret = this.view.getUint24(this.byteOffset, this.littleEndian);\n        this.skipBytes(3);\n        return ret;\n    }\n    readInt24() {\n        const ret = this.view.getInt24(this.byteOffset, this.littleEndian);\n        this.skipBytes(3);\n        return ret;\n    }\n    readUint32() {\n        const ret = this.view.getUint32(this.byteOffset, this.littleEndian);\n        this.skipBytes(4);\n        return ret;\n    }\n    readUint64() {\n        return this.readUint32() * POW32 + this.readUint32();\n    }\n    readInt32() {\n        const ret = this.view.getInt32(this.byteOffset, this.littleEndian);\n        this.skipBytes(4);\n        return ret;\n    }\n    readFloat32() {\n        const ret = this.view.getFloat32(this.byteOffset, this.littleEndian);\n        this.skipBytes(4);\n        return ret;\n    }\n    readFloat64() {\n        const ret = this.view.getFloat64(this.byteOffset, this.littleEndian);\n        this.skipBytes(8);\n        return ret;\n    }\n    readBytes(n) {\n        const byteOffset = this.byteOffset;\n        const ret = this.bytes.subarray(byteOffset, byteOffset + n);\n        this.skipBytes(n);\n        return ret;\n    }\n    readString(n = 0) {\n        let ret;\n        if (n === 0) {\n            const bytes = this.bytes.subarray(this.byteOffset);\n            ret = String.fromCharCode.apply(null, bytes);\n            n = bytes.length;\n        }\n        else {\n            ret = this.view.getString(this.byteOffset, n);\n        }\n        this.skipBytes(n);\n        return ret;\n    }\n    readStringNullTerminated() {\n        const bytes = this.bytes.subarray(this.byteOffset);\n        let i = 0;\n        if (!bytes.byteLength)\n            return \"\";\n        while (bytes[i++] !== 0)\n            ;\n        this.skipBytes(i);\n        return String.fromCharCode.apply(null, bytes.subarray(0, i - 1));\n    }\n    readUTF8StringNullTerminated() {\n        const bytes = this.bytes.subarray(this.byteOffset);\n        let i = 0;\n        if (!bytes.byteLength)\n            return \"\";\n        while (bytes[i++] !== 0)\n            ;\n        this.skipBytes(i);\n        return dataview_1.DataView2.UTF8BytesToString(bytes.subarray(0, i - 1));\n    }\n    skipBits(n) {\n        this.bitOffset += n;\n    }\n    skipBytes(n) {\n        this.bitOffset += n * 8;\n    }\n    get byteOffset() {\n        return this.bitOffset >>> 3;\n    }\n    eof() {\n        return this.bitOffset / 8 >= this.bytes.length;\n    }\n}\nexports.BitReader = BitReader;\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/bitreader.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/bitwriter.js":
/*!*****************************************!*\
  !*** ./vendor/mp4.js/dist/bitwriter.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataview_1 = __webpack_require__(/*! ./dataview */ \"./vendor/mp4.js/dist/dataview.js\");\nconst POW32 = Math.pow(2, 32);\nclass BitWriter {\n    constructor(littleEndian = false) {\n        this.littleEndian = littleEndian;\n        this.bitOffset = 0;\n        this.bytes = new Uint8Array(2);\n        this.view = new dataview_1.DataView2(this.bytes);\n    }\n    get data() {\n        const byteOffset = this.byteOffset;\n        if (byteOffset > this.bytes.length) {\n            const bytes = new Uint8Array(byteOffset);\n            bytes.set(this.bytes);\n            return bytes;\n        }\n        else {\n            return this.bytes.subarray(0, byteOffset);\n        }\n    }\n    get byteOffset() {\n        return this.bitOffset >>> 3;\n    }\n    skipBits(n) {\n        this.bitOffset += n;\n    }\n    skipBytes(n) {\n        this.skipBits(n * 8);\n    }\n    writeBits(n, bitLength) {\n        this.expandBuffer(bitLength);\n        const needBytes = Math.ceil(((this.bitOffset % 8) + bitLength) / 8);\n        let tmp;\n        switch (needBytes) {\n            case 1:\n                tmp = this.view.getUint8(this.byteOffset);\n                break;\n            case 2:\n                tmp = this.view.getUint16(this.byteOffset);\n                break;\n            case 3:\n                tmp = this.view.getUint24(this.byteOffset);\n                break;\n            case 4:\n                tmp = this.view.getUint32(this.byteOffset);\n                break;\n        }\n        tmp |= n << (needBytes * 8 - ((this.bitOffset % 8) + bitLength));\n        switch (needBytes) {\n            case 1:\n                this.view.setUint8(this.byteOffset, tmp);\n                break;\n            case 2:\n                this.view.setUint16(this.byteOffset, tmp);\n                break;\n            case 3:\n                this.view.setUint24(this.byteOffset, tmp);\n                break;\n            case 4:\n                this.view.setUint32(this.byteOffset, tmp);\n                break;\n        }\n        this.skipBits(bitLength);\n    }\n    writeBytes(bytes) {\n        this.expandBuffer(bytes.length * 8);\n        this.bytes.set(bytes, this.byteOffset);\n        this.skipBytes(bytes.length);\n    }\n    writeUint8(n) {\n        this.expandBuffer(8);\n        this.view.setUint8(this.byteOffset, n);\n        this.skipBytes(1);\n    }\n    writeInt8(n) {\n        this.expandBuffer(8);\n        this.view.setInt8(this.byteOffset, n);\n        this.skipBytes(1);\n    }\n    writeUint16(n) {\n        this.expandBuffer(16);\n        this.view.setUint16(this.byteOffset, n, this.littleEndian);\n        this.skipBytes(2);\n    }\n    writeInt16(n) {\n        this.expandBuffer(16);\n        this.view.setInt16(this.byteOffset, n, this.littleEndian);\n        this.skipBytes(2);\n    }\n    writeUint24(n) {\n        this.expandBuffer(24);\n        this.view.setUint24(this.byteOffset, n, this.littleEndian);\n        this.skipBytes(3);\n    }\n    writeInt24(n) {\n        this.expandBuffer(24);\n        this.view.setInt24(this.byteOffset, n, this.littleEndian);\n        this.skipBytes(3);\n    }\n    writeUint32(n) {\n        this.expandBuffer(32);\n        this.view.setUint32(this.byteOffset, n, this.littleEndian);\n        this.skipBytes(4);\n    }\n    writeUint64(n) {\n        this.expandBuffer(64);\n        this.view.setUint32(this.byteOffset / POW32, n, this.littleEndian);\n        this.skipBytes(4);\n        this.view.setUint32((this.byteOffset & 0xffffffff) >>> 0, n, this.littleEndian);\n        this.skipBytes(4);\n    }\n    writeInt32(n) {\n        this.expandBuffer(32);\n        this.view.setInt32(this.byteOffset, n, this.littleEndian);\n        this.skipBytes(4);\n    }\n    writeFloat32(n) {\n        this.expandBuffer(32);\n        this.view.setFloat32(this.byteOffset, n, this.littleEndian);\n        this.skipBytes(4);\n    }\n    writeFloat64(n) {\n        this.expandBuffer(64);\n        this.view.setFloat64(this.byteOffset, n, this.littleEndian);\n        this.skipBytes(8);\n    }\n    writeString(s) {\n        this.expandBuffer(s.length * 8);\n        this.view.setString(this.byteOffset, s);\n        this.skipBytes(s.length);\n    }\n    writeStringNullTerminated(s) {\n        this.writeString(s + \"\\0\");\n    }\n    writeUTF8String(s) {\n        var UTF8Bytes = dataview_1.DataView2.stringToUTF8Bytes(s);\n        this.expandBuffer(UTF8Bytes.length * 8);\n        this.writeBytes(UTF8Bytes);\n    }\n    writeUTF8StringNullTerminated(s) {\n        this.writeUTF8String(s + \"\\0\");\n    }\n    expandBuffer(expandBitWidth) {\n        let bitLength = this.bytes.length * 8;\n        const originalBitLength = bitLength;\n        while (bitLength < this.bitOffset + expandBitWidth)\n            bitLength *= 2;\n        const bytes = new Uint8Array(Math.ceil(bitLength / 8));\n        bytes.set(this.bytes);\n        this.bytes = bytes;\n        this.view = new dataview_1.DataView2(bytes);\n    }\n}\nexports.BitWriter = BitWriter;\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/bitwriter.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/composer.box.js":
/*!********************************************!*\
  !*** ./vendor/mp4.js/dist/composer.box.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst composer_descr_1 = __webpack_require__(/*! ./composer.descr */ \"./vendor/mp4.js/dist/composer.descr.js\");\nconst statics_1 = __webpack_require__(/*! ./statics */ \"./vendor/mp4.js/dist/statics.js\");\nconst dict = {};\nfunction Type(type) {\n    return function (constructor) {\n        constructor.TYPE = type;\n        dict[type] = constructor;\n        return constructor;\n    };\n}\nclass BoxBuilder extends composer_descr_1.DescriptorBuilderMixin {\n    constructor() {\n        super();\n        this.skipBytes(4);\n        this.writeString(this.constructor.TYPE);\n    }\n    build() {\n        // write box size;\n        this.view.setUint32(0, this.byteOffset);\n        return super.build();\n    }\n    writeBox(box) {\n        var bytes;\n        if (box instanceof Uint8Array) {\n            bytes = box;\n        }\n        else if (box.bytes) {\n            bytes = box.bytes;\n        }\n        else {\n            bytes = createBoxBuilder(box).build();\n        }\n        this.writeBytes(bytes);\n    }\n}\nexports.BoxBuilder = BoxBuilder;\nclass FullBoxBuilder extends BoxBuilder {\n    constructor(box) {\n        super();\n        this.box = box;\n        this.writeUint8(box.version || 0);\n        this.writeUint24(box.flags || 0);\n    }\n}\nexports.FullBoxBuilder = FullBoxBuilder;\nclass BoxListBuilder extends BoxBuilder {\n    constructor(boxes) {\n        super();\n        boxes.forEach(box => this.writeBox(box));\n    }\n}\nexports.BoxListBuilder = BoxListBuilder;\nlet FileTypeBoxBuilder = class FileTypeBoxBuilder extends BoxBuilder {\n    constructor(box) {\n        super();\n        this.writeString(box.majorBrand);\n        this.writeUint32(box.minorVersion);\n        box.compatibleBrands.forEach(brand => this.writeString(brand));\n    }\n};\nFileTypeBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_FILE_TYPE_BOX)\n], FileTypeBoxBuilder);\nexports.FileTypeBoxBuilder = FileTypeBoxBuilder;\nlet MovieBoxBuilder = class MovieBoxBuilder extends BoxListBuilder {\n};\nMovieBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_MOVIE_BOX)\n], MovieBoxBuilder);\nexports.MovieBoxBuilder = MovieBoxBuilder;\nlet MediaDataBoxBuilder = class MediaDataBoxBuilder extends BoxBuilder {\n    constructor(box) {\n        super();\n        this.writeBytes(box.data);\n    }\n};\nMediaDataBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_MEDIA_DATA_BOX)\n], MediaDataBoxBuilder);\nexports.MediaDataBoxBuilder = MediaDataBoxBuilder;\nlet MovieHeaderBoxBuilder = class MovieHeaderBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.creationTime);\n        this.writeUint32(box.modificationTime);\n        this.writeUint32(box.timescale);\n        this.writeUint32(box.duration);\n        this.writeInt32(box.rate * 0x10000);\n        this.writeInt16(box.volume * 0x100);\n        this.skipBytes(2);\n        this.skipBytes(8);\n        box.matrix.forEach(x => this.writeInt32(x));\n        this.skipBytes(4 * 6);\n        this.writeUint32(box.nextTrackID);\n    }\n};\nMovieHeaderBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_MOVIE_HEADER_BOX)\n], MovieHeaderBoxBuilder);\nexports.MovieHeaderBoxBuilder = MovieHeaderBoxBuilder;\nlet TrackBoxBuilder = class TrackBoxBuilder extends BoxListBuilder {\n};\nTrackBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_BOX)\n], TrackBoxBuilder);\nexports.TrackBoxBuilder = TrackBoxBuilder;\nlet TrackHeaderBoxBuilder = class TrackHeaderBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.creationTime);\n        this.writeUint32(box.modificationTime);\n        this.writeUint32(box.trackID);\n        this.skipBytes(4);\n        this.writeUint32(box.duration);\n        this.skipBytes(4 * 2);\n        this.writeInt16(box.layer);\n        this.writeInt16(box.alternateGroup);\n        this.writeInt16(box.volume * 0x100);\n        this.skipBytes(2);\n        box.matrix.forEach(x => this.writeInt32(x));\n        this.writeUint32(box.width * 0x10000);\n        this.writeUint32(box.height * 0x10000);\n    }\n};\nTrackHeaderBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_HEADER_BOX)\n], TrackHeaderBoxBuilder);\nexports.TrackHeaderBoxBuilder = TrackHeaderBoxBuilder;\nlet TrackReferenceBoxBuilder = class TrackReferenceBoxBuilder extends BoxListBuilder {\n};\nTrackReferenceBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_REFERENCE_BOX)\n], TrackReferenceBoxBuilder);\nexports.TrackReferenceBoxBuilder = TrackReferenceBoxBuilder;\nclass TrackReferenceTypeBoxBuilder extends BoxBuilder {\n    constructor(box) {\n        super();\n        box.trackIDs.forEach(id => this.writeUint32(id));\n    }\n}\nexports.TrackReferenceTypeBoxBuilder = TrackReferenceTypeBoxBuilder;\nlet HintTrackReferenceTypeBoxBuilder = class HintTrackReferenceTypeBoxBuilder extends TrackReferenceTypeBoxBuilder {\n};\nHintTrackReferenceTypeBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_HINT_TRACK_REFERENCE_TYPE_BOX)\n], HintTrackReferenceTypeBoxBuilder);\nexports.HintTrackReferenceTypeBoxBuilder = HintTrackReferenceTypeBoxBuilder;\nlet DescribeTrackReferenceTypeBoxBuilder = class DescribeTrackReferenceTypeBoxBuilder extends TrackReferenceTypeBoxBuilder {\n};\nDescribeTrackReferenceTypeBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_DISCRIBE_TRACK_REFERENCE_TYPE_BOX)\n], DescribeTrackReferenceTypeBoxBuilder);\nexports.DescribeTrackReferenceTypeBoxBuilder = DescribeTrackReferenceTypeBoxBuilder;\nlet MediaBoxBuilder = class MediaBoxBuilder extends BoxListBuilder {\n};\nMediaBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_MEDIA_BOX)\n], MediaBoxBuilder);\nexports.MediaBoxBuilder = MediaBoxBuilder;\nlet MediaHeaderBoxBuilder = class MediaHeaderBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.creationTime);\n        this.writeUint32(box.modificationTime);\n        this.writeUint32(box.timescale);\n        this.writeUint32(box.duration);\n        this.skipBits(1);\n        [].forEach.call(box.language, (c, i) => {\n            this.writeBits(box.language.charCodeAt(i) - 0x60, 5);\n        });\n        this.skipBytes(2);\n    }\n};\nMediaHeaderBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_MEDIA_HEADER_BOX)\n], MediaHeaderBoxBuilder);\nexports.MediaHeaderBoxBuilder = MediaHeaderBoxBuilder;\nlet HandlerBoxBuilder = class HandlerBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.skipBytes(4);\n        this.writeString(box.handlerType);\n        this.skipBytes(4 * 3);\n        this.writeUTF8StringNullTerminated(box.name);\n    }\n};\nHandlerBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_HANDLER_BOX)\n], HandlerBoxBuilder);\nexports.HandlerBoxBuilder = HandlerBoxBuilder;\nlet MediaInformationBoxBuilder = class MediaInformationBoxBuilder extends BoxListBuilder {\n};\nMediaInformationBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_MEDIA_INFORMATION_BOX)\n], MediaInformationBoxBuilder);\nexports.MediaInformationBoxBuilder = MediaInformationBoxBuilder;\nlet VideoMediaHeaderBoxBuilder = class VideoMediaHeaderBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint16(box.graphicsmode);\n        box.opcolor.forEach(x => this.writeUint16(x));\n    }\n};\nVideoMediaHeaderBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_VIDEO_MEDIA_HEADER_BOX)\n], VideoMediaHeaderBoxBuilder);\nexports.VideoMediaHeaderBoxBuilder = VideoMediaHeaderBoxBuilder;\nlet SoundMediaHeaderBoxBuilder = class SoundMediaHeaderBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeInt16(box.balance);\n        this.skipBytes(2);\n    }\n};\nSoundMediaHeaderBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_SOUND_MEDIA_HEADER_BOX)\n], SoundMediaHeaderBoxBuilder);\nexports.SoundMediaHeaderBoxBuilder = SoundMediaHeaderBoxBuilder;\nlet HintMediaHeaderBoxBuilder = class HintMediaHeaderBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint16(box.maxPDUsize);\n        this.writeUint16(box.avgPDUsize);\n        this.writeUint32(box.maxbitrate);\n        this.writeUint32(box.avgbitrate);\n        this.skipBytes(4);\n    }\n};\nHintMediaHeaderBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_HINT_MEDIA_HEADER_BOX)\n], HintMediaHeaderBoxBuilder);\nexports.HintMediaHeaderBoxBuilder = HintMediaHeaderBoxBuilder;\nlet NullMediaHeaderBoxBuilder = class NullMediaHeaderBoxBuilder extends FullBoxBuilder {\n};\nNullMediaHeaderBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_NULL_MEDIA_HEADER_BOX)\n], NullMediaHeaderBoxBuilder);\nexports.NullMediaHeaderBoxBuilder = NullMediaHeaderBoxBuilder;\nlet DataInformationBoxBuilder = class DataInformationBoxBuilder extends BoxListBuilder {\n};\nDataInformationBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_DATA_INFORMATION_BOX)\n], DataInformationBoxBuilder);\nexports.DataInformationBoxBuilder = DataInformationBoxBuilder;\nlet DataEntryUrlBoxBuilder = class DataEntryUrlBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUTF8StringNullTerminated(box.location);\n    }\n};\nDataEntryUrlBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_DATA_ENTRY_URL_BOX)\n], DataEntryUrlBoxBuilder);\nexports.DataEntryUrlBoxBuilder = DataEntryUrlBoxBuilder;\nlet DataEntryUrnBoxBuilder = class DataEntryUrnBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUTF8StringNullTerminated(box.name);\n        this.writeUTF8StringNullTerminated(box.location);\n    }\n};\nDataEntryUrnBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_DATA_ENTRY_URN_BOX)\n], DataEntryUrnBoxBuilder);\nexports.DataEntryUrnBoxBuilder = DataEntryUrnBoxBuilder;\nlet DataReferenceBoxBuilder = class DataReferenceBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.entryCount);\n        box.entries.forEach(entry => this.writeBox(entry));\n    }\n};\nDataReferenceBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_DATA_REFERENCE_BOX)\n], DataReferenceBoxBuilder);\nexports.DataReferenceBoxBuilder = DataReferenceBoxBuilder;\nlet SampleTableBoxBuilder = class SampleTableBoxBuilder extends BoxListBuilder {\n};\nSampleTableBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_TABLE_BOX)\n], SampleTableBoxBuilder);\nexports.SampleTableBoxBuilder = SampleTableBoxBuilder;\nlet TimeToSampleBoxBuilder = class TimeToSampleBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.entryCount);\n        box.entries.forEach(entry => {\n            this.writeUint32(entry.sampleCount);\n            this.writeUint32(entry.sampleDelta);\n        });\n    }\n};\nTimeToSampleBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_TIME_TO_SAMPLE_BOX)\n], TimeToSampleBoxBuilder);\nexports.TimeToSampleBoxBuilder = TimeToSampleBoxBuilder;\nlet CompositionOffsetBoxBuilder = class CompositionOffsetBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.entryCount);\n        box.entries.forEach(entry => {\n            this.writeUint32(entry.sampleCount);\n            this.writeUint32(entry.sampleOffset);\n        });\n    }\n};\nCompositionOffsetBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_COMPOSITION_OFFSET_BOX)\n], CompositionOffsetBoxBuilder);\nexports.CompositionOffsetBoxBuilder = CompositionOffsetBoxBuilder;\nclass SampleEntryBuilder extends BoxBuilder {\n    constructor(box) {\n        super();\n        this.skipBytes(6);\n        this.writeUint16(box.dataReferenceIndex);\n    }\n}\nexports.SampleEntryBuilder = SampleEntryBuilder;\nclass HintSampleEntryBuilder extends SampleEntryBuilder {\n    constructor(box) {\n        super(box);\n        this.writeBytes(box.data);\n    }\n}\nexports.HintSampleEntryBuilder = HintSampleEntryBuilder;\nclass VisualSampleEntryBuilder extends SampleEntryBuilder {\n    constructor(box) {\n        super(box);\n        this.skipBytes(2);\n        this.skipBytes(2);\n        this.skipBytes(4 * 3);\n        this.writeUint16(box.width);\n        this.writeUint16(box.height);\n        this.writeUint32(box.horizresolution);\n        this.writeUint32(box.vertresolution);\n        this.skipBytes(4);\n        this.writeUint16(box.frameCount);\n        this.writeString(box.compressorname);\n        this.writeUint16(box.depth);\n        this.writeInt16(-1);\n    }\n}\nexports.VisualSampleEntryBuilder = VisualSampleEntryBuilder;\nlet MP4VisualSampleEntryBuilder = class MP4VisualSampleEntryBuilder extends VisualSampleEntryBuilder {\n    constructor(box) {\n        super(box);\n        box.esBox.type = statics_1.BOX_TYPE_ES_DESCRIPTOR_BOX;\n        this.writeBox(box.esBox);\n    }\n};\nMP4VisualSampleEntryBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_MP4_VISUAL_SAMPLE_ENTRY)\n], MP4VisualSampleEntryBuilder);\nexports.MP4VisualSampleEntryBuilder = MP4VisualSampleEntryBuilder;\nlet ESDBoxBuilder = class ESDBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        box.esDescr.tag = statics_1.DESCR_TAG_ES_DESCRIPTOR;\n        this.writeDescriptor(box.esDescr);\n    }\n};\nESDBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_ES_DESCRIPTOR_BOX)\n], ESDBoxBuilder);\nexports.ESDBoxBuilder = ESDBoxBuilder;\nclass AudioSampleEntryBuilder extends SampleEntryBuilder {\n    constructor(box) {\n        super(box);\n        this.skipBytes(4 * 2);\n        this.writeUint16(box.channelCount);\n        this.writeUint16(box.sampleSize);\n        this.skipBytes(2);\n        this.skipBytes(2);\n        this.writeUint32(box.sampleRate * 0x10000);\n    }\n}\nexports.AudioSampleEntryBuilder = AudioSampleEntryBuilder;\nlet MP4AudioSampleEntryBuilder = class MP4AudioSampleEntryBuilder extends AudioSampleEntryBuilder {\n    constructor(box) {\n        super(box);\n        box.esBox.type = statics_1.BOX_TYPE_ES_DESCRIPTOR_BOX;\n        this.writeBox(box.esBox);\n    }\n};\nMP4AudioSampleEntryBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_MP4_AUDIO_SAMPLE_ENTRY)\n], MP4AudioSampleEntryBuilder);\nexports.MP4AudioSampleEntryBuilder = MP4AudioSampleEntryBuilder;\nlet SampleDescriptionBoxBuilder = class SampleDescriptionBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.entryCount);\n        box.boxes.forEach(b => this.writeBox(b));\n    }\n};\nSampleDescriptionBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_DESCRIPTION_BOX)\n], SampleDescriptionBoxBuilder);\nexports.SampleDescriptionBoxBuilder = SampleDescriptionBoxBuilder;\nlet SampleSizeBoxBuilder = class SampleSizeBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.sampleSize);\n        this.writeUint32(box.sampleCount);\n        if (box.sampleSize === 0) {\n            box.sampleSizes.forEach(size => this.writeUint32(size));\n        }\n    }\n};\nSampleSizeBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_SIZE_BOX)\n], SampleSizeBoxBuilder);\nexports.SampleSizeBoxBuilder = SampleSizeBoxBuilder;\nlet SampleToChunkBoxBuilder = class SampleToChunkBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.entryCount);\n        box.entries.forEach(entry => {\n            this.writeUint32(entry.firstChunk);\n            this.writeUint32(entry.samplesPerChunk);\n            this.writeUint32(entry.sampleDescriptionIndex);\n        });\n    }\n};\nSampleToChunkBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_TO_CHUNK_BOX)\n], SampleToChunkBoxBuilder);\nexports.SampleToChunkBoxBuilder = SampleToChunkBoxBuilder;\nlet ChunkOffsetBoxBuilder = class ChunkOffsetBoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.entryCount);\n        box.chunkOffsets.forEach((offset, i) => this.writeUint32(offset));\n    }\n};\nChunkOffsetBoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_CHUNK_OFFSET_BOX)\n], ChunkOffsetBoxBuilder);\nexports.ChunkOffsetBoxBuilder = ChunkOffsetBoxBuilder;\nlet ChunkOffset64BoxBuilder = class ChunkOffset64BoxBuilder extends FullBoxBuilder {\n    constructor(box) {\n        super(box);\n        this.writeUint32(box.entryCount);\n        box.chunkOffsets.forEach((offset, i) => this.writeUint64(offset));\n    }\n};\nChunkOffset64BoxBuilder = __decorate([\n    Type(statics_1.BOX_TYPE_CHUNK_OFFSET64_BOX)\n], ChunkOffset64BoxBuilder);\nexports.ChunkOffset64BoxBuilder = ChunkOffset64BoxBuilder;\nvar createBoxBuilder = (box) => {\n    return new (dict[box.type] || BoxBuilder)(box);\n};\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/composer.box.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/composer.descr.js":
/*!**********************************************!*\
  !*** ./vendor/mp4.js/dist/composer.descr.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst composer_1 = __webpack_require__(/*! ./composer */ \"./vendor/mp4.js/dist/composer.js\");\nconst statics_1 = __webpack_require__(/*! ./statics */ \"./vendor/mp4.js/dist/statics.js\");\nconst dict = {};\nfunction Tag(tag) {\n    return function (constructor) {\n        constructor.TAG = tag;\n        dict[tag] = constructor;\n        return constructor;\n    };\n}\nclass DescriptorBuilderMixin extends composer_1.BaseBuilder {\n    writeDescriptor(descr) {\n        var bytes;\n        if (descr instanceof Uint8Array) {\n            bytes = descr;\n        }\n        else if (descr.bytes) {\n            bytes = descr.bytes;\n        }\n        else {\n            bytes = exports.createDescriptorBuilder(descr).build();\n        }\n        this.writeBytes(bytes);\n    }\n}\nexports.DescriptorBuilderMixin = DescriptorBuilderMixin;\nclass DescriptorBuilder extends DescriptorBuilderMixin {\n    constructor() {\n        super();\n        this.writeUint8(this.constructor.TAG);\n        this.writeBytes(new Uint8Array(4));\n    }\n    build() {\n        this.writeBodyLength();\n        return super.build();\n    }\n    writeBodyLength() {\n        var bytes = [0x80, 0x80, 0x80, 0x00];\n        var bodyLength = this.byteOffset - 5;\n        var i = 3;\n        while (bodyLength) {\n            bytes[i--] |= bodyLength & 0x7f;\n            bodyLength >>>= 7;\n        }\n        this.bytes.set(bytes, 1);\n    }\n}\nexports.DescriptorBuilder = DescriptorBuilder;\nlet DecoderConfigDescriptorBuilder = class DecoderConfigDescriptorBuilder extends DescriptorBuilder {\n    constructor(descr) {\n        super();\n        this.writeUint8(descr.objectTypeIndication);\n        this.writeBits(descr.streamType, 6);\n        this.writeBits(descr.upStream, 1);\n        this.writeBits(1, 1);\n        this.writeUint24(descr.bufferSizeDB);\n        this.writeUint32(descr.maxBitrate);\n        this.writeUint32(descr.avgBitrate);\n        descr.decSpecificInfo.tag = statics_1.DESCR_TAG_DECODER_SPECIFIC_INFO;\n        this.writeDescriptor(descr.decSpecificInfo);\n        if (descr.profileLevelIndicationIndexDescrs) {\n            descr.profileLevelIndicationIndexDescrs.forEach(d => {\n                d.tag = statics_1.DESCR_TAG_PROFILE_LEVEL_INDICATION_INDEX_DESCRIPTOR;\n                this.writeDescriptor(d);\n            });\n        }\n    }\n};\nDecoderConfigDescriptorBuilder = __decorate([\n    Tag(statics_1.DESCR_TAG_DECODER_CONFIG_DESCRIPTOR)\n], DecoderConfigDescriptorBuilder);\nexports.DecoderConfigDescriptorBuilder = DecoderConfigDescriptorBuilder;\nlet SLConfigDescriptorBuilder = class SLConfigDescriptorBuilder extends DescriptorBuilder {\n    constructor(descr) {\n        super();\n        this.writeUint8(descr.preDefined);\n        if (descr.preDefined === 0) {\n            this.writeBits(descr.useAccessUnitStartFlag, 1);\n            this.writeBits(descr.useAccessUnitEndFlag, 1);\n            this.writeBits(descr.useRandomAccessPointFlag, 1);\n            this.writeBits(descr.hasRandomAccessUnitsOnlyFlag, 1);\n            this.writeBits(descr.usePaddingFlag, 1);\n            this.writeBits(descr.useTimeStampsFlag, 1);\n            this.writeBits(descr.useTimeStampsFlag, 1);\n            this.writeBits(descr.useIdleFlag, 1);\n            this.writeBits(descr.durationFlag, 1);\n            this.writeUint32(descr.timeStampResolution);\n            this.writeUint32(descr.ocrResolution);\n            this.writeUint8(descr.timeStampLength);\n            this.writeUint8(descr.ocrLength);\n            this.writeUint8(descr.auLength);\n            this.writeUint8(descr.instantBitrateLength);\n            this.writeBits(descr.degradationPriorityLength, 4);\n            this.writeBits(descr.auSeqNumLength, 5);\n            this.writeBits(descr.packetSeqNumLength, 5);\n            this.writeBits(3, 2);\n        }\n        if (descr.durationFlag) {\n            this.writeUint32(descr.timeScale);\n            this.writeUint16(descr.accessUnitDuration);\n            this.writeUint16(descr.compositionUnitDuration);\n        }\n        if (descr.useTimeStampsFlag === 0) {\n            this.writeBits(descr.startDecodingTimeStamp, descr.timeStampLength);\n            this.writeBits(descr.startCompositionTimeStamp, descr.timeStampLength);\n        }\n    }\n};\nSLConfigDescriptorBuilder = __decorate([\n    Tag(statics_1.DESCR_TAG_SL_CONFIG_DESCRIPTOR)\n], SLConfigDescriptorBuilder);\nexports.SLConfigDescriptorBuilder = SLConfigDescriptorBuilder;\nlet DecoderSpecificInfoBuilder = class DecoderSpecificInfoBuilder extends DescriptorBuilder {\n    constructor(descr) {\n        super();\n        this.writeBytes(descr.data);\n    }\n};\nDecoderSpecificInfoBuilder = __decorate([\n    Tag(statics_1.DESCR_TAG_DECODER_SPECIFIC_INFO)\n], DecoderSpecificInfoBuilder);\nexports.DecoderSpecificInfoBuilder = DecoderSpecificInfoBuilder;\nlet ESDescriptorBuilder = class ESDescriptorBuilder extends DescriptorBuilder {\n    constructor(descr) {\n        super();\n        this.writeUint16(descr.esID);\n        this.writeBits(descr.streamDependenceFlag || 0, 1);\n        this.writeBits(descr.urlFlag || 0, 1);\n        this.writeBits(descr.ocrStreamFlag || 0, 1);\n        this.writeBits(descr.streamPriority, 5);\n        if (descr.urlFlag) {\n            this.writeUint8(descr.urlLength);\n            this.writeString(descr.urlString);\n        }\n        if (descr.ocrStreamFlag) {\n            this.writeUint16(descr.ocrEsID);\n        }\n        descr.decConfigDescr.tag = statics_1.DESCR_TAG_DECODER_CONFIG_DESCRIPTOR;\n        this.writeDescriptor(descr.decConfigDescr);\n        descr.slConfigDescr.tag = statics_1.DESCR_TAG_SL_CONFIG_DESCRIPTOR;\n        this.writeDescriptor(descr.slConfigDescr);\n    }\n};\nESDescriptorBuilder = __decorate([\n    Tag(statics_1.DESCR_TAG_ES_DESCRIPTOR)\n], ESDescriptorBuilder);\nexports.ESDescriptorBuilder = ESDescriptorBuilder;\nexports.createDescriptorBuilder = (descr) => {\n    return new (dict[descr.tag] || DescriptorBuilder)(descr);\n};\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/composer.descr.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/composer.js":
/*!****************************************!*\
  !*** ./vendor/mp4.js/dist/composer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitwriter_1 = __webpack_require__(/*! ./bitwriter */ \"./vendor/mp4.js/dist/bitwriter.js\");\nclass BaseBuilder extends bitwriter_1.BitWriter {\n    build() {\n        return this.data;\n    }\n}\nexports.BaseBuilder = BaseBuilder;\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/composer.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/dataview.js":
/*!****************************************!*\
  !*** ./vendor/mp4.js/dist/dataview.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst toString = Object.prototype.toString;\nlet BUFF8 = new Uint8Array(0x8000);\nlet BUFF16 = new Uint16Array(BUFF8.buffer);\nlet BUFF32 = new Uint32Array(BUFF8.buffer);\nconst expandBuffer = (expandWidth) => {\n    const n = BUFF8.byteLength + expandWidth;\n    let m = BUFF8.byteLength;\n    while (m < n)\n        m *= 2;\n    const bytes = new Uint8Array(m);\n    bytes.set(BUFF8);\n    BUFF8 = bytes;\n    BUFF16 = new Uint16Array(bytes.buffer);\n    BUFF32 = new Uint32Array(bytes.buffer);\n};\nclass DataView2 {\n    constructor(buffer, byteOffset, byteLength) {\n        if (typeof buffer === \"number\") {\n            this.view = new DataView(new ArrayBuffer(buffer));\n        }\n        else {\n            switch (toString.call(buffer)) {\n                case \"[object ArrayBuffer]\":\n                    byteOffset = byteOffset || 0;\n                    byteLength = byteLength || buffer.byteLength;\n                    this.view = new DataView(buffer, byteOffset, byteLength);\n                    break;\n                case \"[object Uint8Array]\":\n                case \"[object Uint8ClampedArray]\":\n                case \"[object CanvasPixelArray]\":\n                case \"[object Int8Array]\":\n                case \"[object Uint16Array]\":\n                case \"[object Int16Array]\":\n                case \"[object Uint32Array]\":\n                case \"[object Int32Array]\":\n                case \"[object Float32Array]\":\n                case \"[object Float64Array]\":\n                case \"[object DataView]\":\n                    if (byteOffset === undefined && byteLength === undefined) {\n                        this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n                    }\n                    else if (byteOffset !== undefined && byteLength === undefined) {\n                        this.view = new DataView(buffer.buffer, buffer.byteOffset + byteOffset);\n                    }\n                    else if (byteOffset === undefined && byteLength !== undefined) {\n                        this.view = new DataView(buffer.buffer, buffer.byteOffset, byteLength);\n                    }\n                    else {\n                        this.view = new DataView(buffer.buffer, byteOffset, byteLength);\n                    }\n                    break;\n                default:\n                    throw new TypeError();\n            }\n        }\n        this.buffer = this.view.buffer;\n        this.byteOffset = this.view.byteOffset;\n        this.byteLength = this.view.byteLength;\n    }\n    getUint8(byteOffset) {\n        return this.view.getUint8(byteOffset);\n    }\n    setUint8(byteOffset, value) {\n        this.view.setUint8(byteOffset, value);\n    }\n    getInt8(byteOffset) {\n        return this.view.getInt8(byteOffset);\n    }\n    setInt8(byteOffset, value) {\n        this.view.setInt8(byteOffset, value);\n    }\n    getUint16(byteOffset, littleEndian = false) {\n        return this.view.getUint16(byteOffset, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian = false) {\n        this.view.setUint16(byteOffset, value, littleEndian);\n    }\n    getInt16(byteOffset, littleEndian = false) {\n        return this.view.getInt16(byteOffset, littleEndian);\n    }\n    setInt16(byteOffset, value, littleEndian = false) {\n        this.view.setInt16(byteOffset, value, littleEndian);\n    }\n    getUint32(byteOffset, littleEndian = false) {\n        return this.view.getUint32(byteOffset, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian = false) {\n        this.view.setUint32(byteOffset, value, littleEndian);\n    }\n    getInt32(byteOffset, littleEndian = false) {\n        return this.view.getInt32(byteOffset, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian = false) {\n        this.view.setInt32(byteOffset, value, littleEndian);\n    }\n    getFloat32(byteOffset, littleEndian = false) {\n        return this.view.getFloat32(byteOffset, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian = false) {\n        this.view.setFloat32(byteOffset, value, littleEndian);\n    }\n    getFloat64(byteOffset, littleEndian = false) {\n        return this.view.getFloat64(byteOffset, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian = false) {\n        this.view.setFloat64(byteOffset, value, littleEndian);\n    }\n    getString(byteOffset, byteLength) {\n        const bytes = new Uint8Array(this.buffer, this.byteOffset + byteOffset, byteLength);\n        return String.fromCharCode.apply(null, bytes);\n    }\n    setString(byteOffset, s) {\n        const bytes = new Uint8Array(this.buffer, this.byteOffset + byteOffset);\n        let i = s.length;\n        while (i)\n            bytes[--i] = s.charCodeAt(i);\n    }\n    getUTF8String(byteOffset, byteLength) {\n        const bytes = new Uint8Array(this.buffer, this.byteOffset + byteOffset, this.byteLength);\n        return DataView2.UTF8BytesToString(bytes);\n    }\n    static stringToUTF8Bytes(s) {\n        let n = s.length, idx = -1, buff = BUFF8, byteLength = buff.byteLength, i, c;\n        for (i = 0; i < n; ++i) {\n            c = s.charCodeAt(i);\n            if (c <= 0x7f) {\n                buff[++idx] = c;\n            }\n            else if (c <= 0x7ff) {\n                buff[++idx] = 0xc0 | (c >>> 6);\n                buff[++idx] = 0x80 | (c & 0x3f);\n            }\n            else if (c <= 0xffff) {\n                buff[++idx] = 0xe0 | (c >>> 12);\n                buff[++idx] = 0x80 | ((c >>> 6) & 0x3f);\n                buff[++idx] = 0x80 | (c & 0x3f);\n            }\n            else {\n                buff[++idx] = 0xf0 | (c >>> 18);\n                buff[++idx] = 0x80 | ((c >>> 12) & 0x3f);\n                buff[++idx] = 0x80 | ((c >>> 6) & 0x3f);\n                buff[++idx] = 0x80 | (c & 0x3f);\n            }\n            if (byteLength - idx <= 4) {\n                expandBuffer(4);\n                buff = BUFF8;\n            }\n        }\n        const bytes = new Uint8Array(++idx);\n        bytes.set(buff.subarray(0, idx));\n        return bytes;\n    }\n    static UTF8BytesToString(bytes) {\n        const n = bytes.byteLength;\n        const buff = BUFF32;\n        let idx = 0;\n        let i = 0;\n        let c;\n        let ret = \"\";\n        while (i < n) {\n            for (idx = 0; idx < 0x1000 && i < n; ++i, ++idx) {\n                c = bytes[i];\n                if (c < 0x80) {\n                    buff[idx] = c;\n                }\n                else if (c >>> 5 === 0x06) {\n                    buff[idx] = (c & 0x1f) << 6;\n                    buff[idx] |= bytes[++i] & 0x3f;\n                }\n                else if (c >>> 4 === 0x0e) {\n                    buff[idx] = (c & 0x0f) << 12;\n                    buff[idx] |= (bytes[++i] & 0x3f) << 6;\n                    buff[idx] |= bytes[++i] & 0x3f;\n                }\n                else {\n                    buff[idx] = (c & 0x07) << 18;\n                    buff[idx] |= (bytes[++i] & 0x3f) << 12;\n                    buff[idx] |= (bytes[++i] & 0x3f) << 6;\n                    buff[idx] |= bytes[++i] & 0x3f;\n                }\n            }\n            ret += String.fromCharCode.apply(null, buff.subarray(0, idx));\n        }\n        return ret;\n    }\n    setUTF8String(byteOffset, s) {\n        const UTF8Bytes = DataView2.stringToUTF8Bytes(s);\n        const bytes = new Uint8Array(this.buffer, this.byteOffset, this.byteLength);\n        bytes.set(UTF8Bytes, byteOffset);\n        return UTF8Bytes.length;\n    }\n    getUint24(byteOffset, littleEndian = false) {\n        const b = new Uint8Array(this.buffer, this.byteOffset + byteOffset);\n        return littleEndian\n            ? b[0] | (b[1] << 8) | (b[2] << 16)\n            : b[2] | (b[1] << 8) | (b[0] << 16);\n    }\n    setUint24(byteOffset, value, littleEndian = false) {\n        const b = new Uint8Array(this.buffer, this.byteOffset + byteOffset);\n        if (littleEndian) {\n            b[0] = value & 0xff;\n            b[1] = (value & 0xff00) >> 8;\n            b[2] = (value & 0xff0000) >> 16;\n        }\n        else {\n            b[2] = value & 0xff;\n            b[1] = (value & 0xff00) >> 8;\n            b[0] = (value & 0xff0000) >> 16;\n        }\n    }\n    getInt24(byteOffset, littleEndian = false) {\n        const v = this.getUint24(byteOffset, littleEndian);\n        return v & 0x800000 ? v - 0x1000000 : v;\n    }\n    setInt24(byteOffset, value, littleEndian = false) {\n        this.setUint24(byteOffset, value, littleEndian);\n    }\n}\nexports.DataView2 = DataView2;\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/dataview.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/finder.js":
/*!**************************************!*\
  !*** ./vendor/mp4.js/dist/finder.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Finder {\n    constructor(tree) {\n        this.tree = tree;\n    }\n    findOne(type) {\n        let box;\n        const find = (tree) => {\n            if (box)\n                return;\n            switch (typeof tree) {\n                case \"number\":\n                case \"string\":\n                case \"boolean\":\n                    return;\n            }\n            if (tree.type === type) {\n                return (box = tree);\n            }\n            if (tree.buffer)\n                return;\n            Object.keys(tree).forEach(key => {\n                const prop = tree[key];\n                if (prop == null)\n                    return;\n                if (Array.isArray(prop)) {\n                    prop.some(find);\n                }\n                else if (prop.type) {\n                    find(prop);\n                }\n            });\n        };\n        find(this.tree);\n        return box;\n    }\n    findAll(type) {\n        const boxes = [];\n        const find = (tree) => {\n            switch (typeof tree) {\n                case \"number\":\n                case \"string\":\n                case \"boolean\":\n                    return;\n            }\n            if (tree.type === type)\n                boxes.push(tree);\n            if (tree.buffer)\n                return;\n            Object.keys(tree).forEach(key => {\n                const prop = tree[key];\n                if (prop == null)\n                    return;\n                if (Array.isArray(prop)) {\n                    prop.forEach(find);\n                }\n                else {\n                    find(prop);\n                }\n            });\n        };\n        find(this.tree);\n        return boxes;\n    }\n}\nexports.Finder = Finder;\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/finder.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/index.js":
/*!*************************************!*\
  !*** ./vendor/mp4.js/dist/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitreader_1 = __webpack_require__(/*! ./bitreader */ \"./vendor/mp4.js/dist/bitreader.js\");\nconst finder_1 = __webpack_require__(/*! ./finder */ \"./vendor/mp4.js/dist/finder.js\");\nconst bitwriter_1 = __webpack_require__(/*! ./bitwriter */ \"./vendor/mp4.js/dist/bitwriter.js\");\nconst dataview_1 = __webpack_require__(/*! ./dataview */ \"./vendor/mp4.js/dist/dataview.js\");\nconst apis = __importStar(__webpack_require__(/*! ./mp4 */ \"./vendor/mp4.js/dist/mp4.js\"));\nconst statics = __importStar(__webpack_require__(/*! ./statics */ \"./vendor/mp4.js/dist/statics.js\"));\nconst boxBuilders = __importStar(__webpack_require__(/*! ./composer.box */ \"./vendor/mp4.js/dist/composer.box.js\"));\nconst descrBuilders = __importStar(__webpack_require__(/*! ./composer.descr */ \"./vendor/mp4.js/dist/composer.descr.js\"));\nconst boxParsers = __importStar(__webpack_require__(/*! ./parser.box */ \"./vendor/mp4.js/dist/parser.box.js\"));\nconst descrParsers = __importStar(__webpack_require__(/*! ./parser.descr */ \"./vendor/mp4.js/dist/parser.descr.js\"));\nexports.Mp4 = Object.assign({ DataView2: dataview_1.DataView2,\n    BitReader: bitreader_1.BitReader,\n    BitWriter: bitwriter_1.BitWriter,\n    Finder: finder_1.Finder }, apis, statics, { Builder: Object.assign({}, boxBuilders, descrBuilders), Parser: Object.assign({}, boxParsers, descrParsers) });\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/index.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/mp4.js":
/*!***********************************!*\
  !*** ./vendor/mp4.js/dist/mp4.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parser_box_1 = __webpack_require__(/*! ./parser.box */ \"./vendor/mp4.js/dist/parser.box.js\");\nconst finder_1 = __webpack_require__(/*! ./finder */ \"./vendor/mp4.js/dist/finder.js\");\nconst statics_1 = __webpack_require__(/*! ./statics */ \"./vendor/mp4.js/dist/statics.js\");\nconst composer_box_1 = __webpack_require__(/*! ./composer.box */ \"./vendor/mp4.js/dist/composer.box.js\");\nconst parser_descr_1 = __webpack_require__(/*! ./parser.descr */ \"./vendor/mp4.js/dist/parser.descr.js\");\nconst bitreader_1 = __webpack_require__(/*! ./bitreader */ \"./vendor/mp4.js/dist/bitreader.js\");\nvar SAMPLERATE_TABLE = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000\n];\nexports.parse = (bytes) => {\n    return new parser_box_1.RootParser(bytes).parse();\n};\nvar getChunks = (bytes, trackBox) => {\n    var chunks = [];\n    var finder = new finder_1.Finder(trackBox);\n    var stsc = finder.findOne(statics_1.BOX_TYPE_SAMPLE_TO_CHUNK_BOX);\n    var stsz = finder.findOne(statics_1.BOX_TYPE_SAMPLE_SIZE_BOX);\n    var stco = finder.findOne(statics_1.BOX_TYPE_CHUNK_OFFSET_BOX);\n    if (!stco)\n        stco = finder.findOne(statics_1.BOX_TYPE_CHUNK_OFFSET64_BOX);\n    var i, j, k, idx, n, m, l, chunkStart, chunkEnd;\n    for (i = 0, idx = 0, n = stsc.entryCount; i < n; ++i) {\n        j = stsc.entries[i].firstChunk - 1;\n        m =\n            i + 1 < n ? stsc.entries[i + 1].firstChunk - 1 : stco.chunkOffsets.length;\n        for (; j < m; ++j) {\n            chunkStart = chunkEnd = stco.chunkOffsets[j];\n            for (k = 0, l = stsc.entries[i].samplesPerChunk; k < l; ++k, ++idx) {\n                chunkEnd += stsz.sampleSizes[idx];\n            }\n            chunks.push(bytes.subarray(chunkStart, chunkEnd));\n        }\n    }\n    return chunks;\n};\nvar getAudioTrack = (tree) => {\n    var audioTrack;\n    var finder = new finder_1.Finder(tree);\n    finder.findAll(statics_1.BOX_TYPE_TRACK_BOX).some(box => {\n        var hdlr = new finder_1.Finder(box).findOne(statics_1.BOX_TYPE_HANDLER_BOX);\n        if (hdlr.handlerType === \"soun\") {\n            audioTrack = box;\n            return true;\n        }\n        return false;\n    });\n    return audioTrack;\n};\nvar concatBytes = (bytess) => {\n    var i, n, byteLength = 0, offset = 0;\n    for (i = 0, n = bytess.length; i < n; ++i) {\n        byteLength += bytess[i].length;\n    }\n    var ret = new Uint8Array(byteLength);\n    for (i = 0; i < n; ++i) {\n        ret.set(bytess[i], offset);\n        offset += bytess[i].length;\n    }\n    return ret;\n};\n// extract audio. it is stored to MP4 container.\nexports.extractAudio = (bytes) => {\n    var tree = exports.parse(bytes);\n    var finder = new finder_1.Finder(tree);\n    var offset = 8 * 6;\n    var ftyp = {\n        majorBrand: \"M4A \",\n        minorVersion: 1,\n        compatibleBrands: [\"isom\", \"M4A \", \"mp42\"]\n    };\n    ftyp.bytes = new composer_box_1.FileTypeBoxBuilder(ftyp).build();\n    offset += ftyp.bytes.length;\n    var mvhd = finder.findOne(statics_1.BOX_TYPE_MOVIE_HEADER_BOX);\n    offset += mvhd.bytes.length;\n    var audioTrack = getAudioTrack(tree);\n    finder = new finder_1.Finder(audioTrack);\n    var tkhd = finder.findOne(statics_1.BOX_TYPE_TRACK_HEADER_BOX);\n    offset += tkhd.bytes.length;\n    finder = new finder_1.Finder(finder.findOne(statics_1.BOX_TYPE_MEDIA_BOX));\n    var mdhd = finder.findOne(statics_1.BOX_TYPE_MEDIA_HEADER_BOX);\n    var hdlr = finder.findOne(statics_1.BOX_TYPE_HANDLER_BOX);\n    offset += mdhd.bytes.length + hdlr.bytes.length;\n    finder = new finder_1.Finder(finder.findOne(statics_1.BOX_TYPE_MEDIA_INFORMATION_BOX));\n    var smhd = finder.findOne(statics_1.BOX_TYPE_SOUND_MEDIA_HEADER_BOX);\n    var dinf = finder.findOne(statics_1.BOX_TYPE_DATA_INFORMATION_BOX);\n    offset += smhd.bytes.length + dinf.bytes.length;\n    finder = new finder_1.Finder(finder.findOne(statics_1.BOX_TYPE_SAMPLE_TABLE_BOX));\n    var stsd = finder.findOne(statics_1.BOX_TYPE_SAMPLE_DESCRIPTION_BOX);\n    var stts = finder.findOne(statics_1.BOX_TYPE_TIME_TO_SAMPLE_BOX);\n    var stsc = finder.findOne(statics_1.BOX_TYPE_SAMPLE_TO_CHUNK_BOX);\n    var stsz = finder.findOne(statics_1.BOX_TYPE_SAMPLE_SIZE_BOX);\n    var stco = finder.findOne(statics_1.BOX_TYPE_CHUNK_OFFSET_BOX);\n    if (!stco)\n        stco = finder.findOne(statics_1.BOX_TYPE_CHUNK_OFFSET64_BOX);\n    var stcoBytes = stco.bytes;\n    offset +=\n        stsd.bytes.length +\n            stts.bytes.length +\n            stsc.bytes.length +\n            stsz.bytes.length +\n            stcoBytes.length;\n    var chunks = getChunks(bytes, audioTrack);\n    var chunkOffsets = [offset];\n    for (var i = 1, n = chunks.length; i < n; ++i) {\n        offset += chunks[i - 1].length;\n        chunkOffsets[i] = offset;\n    }\n    stcoBytes = new (stco.type === statics_1.BOX_TYPE_CHUNK_OFFSET_BOX\n        ? composer_box_1.ChunkOffsetBoxBuilder\n        : composer_box_1.ChunkOffset64BoxBuilder)({\n        entryCount: stco.entryCount,\n        chunkOffsets: chunkOffsets\n    }).build();\n    var mdatBytes = new composer_box_1.MediaDataBoxBuilder({\n        data: concatBytes(chunks)\n    }).build();\n    var stblBytes = new composer_box_1.SampleTableBoxBuilder([\n        stsd,\n        stts,\n        stsc,\n        stsz,\n        stcoBytes\n    ]).build();\n    var minfBytes = new composer_box_1.MediaInformationBoxBuilder([\n        smhd,\n        dinf,\n        stblBytes\n    ]).build();\n    var mdiaBytes = new composer_box_1.MediaBoxBuilder([mdhd, hdlr, minfBytes]).build();\n    var trakBytes = new composer_box_1.TrackBoxBuilder([tkhd, mdiaBytes]).build();\n    var moovBytes = new composer_box_1.MovieBoxBuilder([mvhd, trakBytes]).build();\n    return concatBytes([ftyp.bytes, moovBytes, mdatBytes]);\n};\nvar extractAudioAsAAC = (bytes, audioTrack) => {\n    var finder = new finder_1.Finder(audioTrack);\n    var mp4a = (finder.findOne(statics_1.BOX_TYPE_MP4_AUDIO_SAMPLE_ENTRY));\n    var stsc = finder.findOne(statics_1.BOX_TYPE_SAMPLE_TO_CHUNK_BOX);\n    var stsz = finder.findOne(statics_1.BOX_TYPE_SAMPLE_SIZE_BOX);\n    var stco = finder.findOne(statics_1.BOX_TYPE_CHUNK_OFFSET_BOX);\n    if (!stco)\n        stco = finder.findOne(statics_1.BOX_TYPE_CHUNK_OFFSET64_BOX);\n    var ret = new Uint8Array(stsz.sampleSizes.length * 7 + stsz.sampleSizes.reduce((a, b) => a + b));\n    var offset = 0;\n    var aacHeader = new Uint8Array(7);\n    aacHeader[0] = 0xff;\n    aacHeader[1] = 0xf9;\n    aacHeader[2] =\n        0x40 |\n            (SAMPLERATE_TABLE.indexOf(mp4a.sampleRate) << 2) |\n            (mp4a.channelCount >> 2);\n    aacHeader[6] = 0xfc;\n    var i, j, k, idx, n, m, l, chunkOffset, sampleSize;\n    for (i = 0, idx = 0, n = stsc.entryCount; i < n; ++i) {\n        j = stsc.entries[i].firstChunk - 1;\n        m =\n            i + 1 < n ? stsc.entries[i + 1].firstChunk - 1 : stco.chunkOffsets.length;\n        for (; j < m; ++j) {\n            chunkOffset = stco.chunkOffsets[j];\n            for (k = 0, l = stsc.entries[i].samplesPerChunk; k < l; ++k, ++idx) {\n                sampleSize = stsz.sampleSizes[idx] + 7;\n                aacHeader[3] = (mp4a.channelCount << 6) | (sampleSize >> 11);\n                aacHeader[4] = sampleSize >> 3;\n                aacHeader[5] = (sampleSize << 5) | (0x7ff >> 6);\n                ret.set(aacHeader, offset);\n                offset += 7;\n                ret.set(bytes.subarray(chunkOffset, (chunkOffset += stsz.sampleSizes[idx])), offset);\n                offset += stsz.sampleSizes[idx];\n            }\n        }\n    }\n    return ret;\n};\nvar extractAudioAsMP3 = (bytes, audioTrack) => {\n    return concatBytes(getChunks(bytes, audioTrack));\n};\nexports.extractRawAudio = (bytes) => {\n    var tree = exports.parse(bytes);\n    var audioTrack = getAudioTrack(tree);\n    var finder = new finder_1.Finder(audioTrack);\n    var mp4a = (finder.findOne(statics_1.BOX_TYPE_MP4_AUDIO_SAMPLE_ENTRY));\n    var OBJECT_TYPE_INDICATION = parser_descr_1.DecoderConfigDescriptorParser.OBJECT_TYPE_INDICATION;\n    switch (mp4a.esBox.esDescr.decConfigDescr.objectTypeIndication) {\n        case OBJECT_TYPE_INDICATION.AAC:\n            return { type: \"aac\", data: extractAudioAsAAC(bytes, audioTrack) };\n        case OBJECT_TYPE_INDICATION.MP3:\n            return { type: \"mp3\", data: extractAudioAsMP3(bytes, audioTrack) };\n        default:\n            throw new TypeError(\"not supported object type indication.\");\n    }\n};\nexports.aacToM4a = (bytes) => {\n    var bitReader = new bitreader_1.BitReader(bytes);\n    var offset = 8 * 6;\n    bitReader.skipBits(12);\n    var aacInfo = {\n        id: bitReader.readBits(1),\n        layer: bitReader.readBits(2),\n        protectionAbsent: bitReader.readBits(1),\n        profile: bitReader.readBits(2),\n        sampleingFrequencyIndex: bitReader.readBits(4),\n        privateBit: bitReader.readBits(1),\n        channelConfiguration: bitReader.readBits(3),\n        original: bitReader.readBits(1),\n        home: bitReader.readBits(1),\n        copyrightIndentificationBit: bitReader.readBits(1),\n        copyrightIndentificationStart: bitReader.readBits(1),\n        aacFrameLength: bitReader.readBits(13),\n        atdsBufferFullness: bitReader.readBits(11),\n        noRawDataBlocksInFrames: bitReader.readBits(2)\n    };\n    bitReader.bitOffset = 0;\n    var samples = [];\n    var frameLength;\n    var bufferSizeDB = 0;\n    while (!bitReader.eof()) {\n        bitReader.skipBits(30);\n        frameLength = bitReader.readBits(13);\n        bitReader.skipBits(13);\n        samples.push(bitReader.readBytes(frameLength - 7));\n        bufferSizeDB = Math.max(bufferSizeDB, frameLength - 7);\n    }\n    var ftypBytes = new composer_box_1.FileTypeBoxBuilder({\n        majorBrand: \"M4A \",\n        minorVersion: 1,\n        compatibleBrands: [\"isom\", \"M4A \", \"mp42\"]\n    }).build();\n    offset += ftypBytes.length;\n    var creationTime = Date.now();\n    var timescale = 600;\n    var sampleRate = SAMPLERATE_TABLE[aacInfo.sampleingFrequencyIndex];\n    var duration = ((samples.length * 1024 * timescale) / sampleRate) | 0;\n    var matrix = [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000];\n    var mvhdBytes = new composer_box_1.MovieHeaderBoxBuilder({\n        creationTime: creationTime,\n        modificationTime: creationTime,\n        timescale: timescale,\n        duration: duration,\n        rate: 1.0,\n        volume: 1.0,\n        matrix: matrix,\n        nextTrackID: 2\n    }).build();\n    offset += mvhdBytes.length;\n    var tkhdBytes = new composer_box_1.TrackHeaderBoxBuilder({\n        flags: 0x000001,\n        creationTime: creationTime,\n        modificationTime: creationTime,\n        trackID: 1,\n        duration: duration,\n        layer: 0,\n        alternateGroup: 0,\n        volume: 1.0,\n        matrix: matrix,\n        width: 0,\n        height: 0\n    }).build();\n    offset += tkhdBytes.length;\n    var mdhdBytes = new composer_box_1.MediaHeaderBoxBuilder({\n        creationTime: creationTime,\n        modificationTime: creationTime,\n        timescale: timescale,\n        duration: duration,\n        language: \"und\"\n    }).build();\n    offset += mdhdBytes.length;\n    var hdlrBytes = new composer_box_1.HandlerBoxBuilder({\n        handlerType: \"soun\",\n        name: \"mp4.js sound media handler\"\n    }).build();\n    offset += hdlrBytes.length;\n    var smhdBytes = new composer_box_1.SoundMediaHeaderBoxBuilder({\n        balance: 0\n    }).build();\n    offset += smhdBytes.length;\n    var urlBytes = new composer_box_1.DataEntryUrlBoxBuilder({\n        flags: 0x000001,\n        location: \"\"\n    }).build();\n    var drefBytes = new composer_box_1.DataReferenceBoxBuilder({\n        entryCount: 1,\n        entries: [urlBytes]\n    }).build();\n    var dinfBytes = new composer_box_1.DataInformationBoxBuilder([drefBytes]).build();\n    offset += dinfBytes.length;\n    var OBJECT_TYPE_INDICATION = parser_descr_1.DecoderConfigDescriptorParser.OBJECT_TYPE_INDICATION;\n    var decConfigDescr = {\n        objectTypeIndication: OBJECT_TYPE_INDICATION.AAC,\n        streamType: 0x05,\n        upStream: 0,\n        bufferSizeDB: bufferSizeDB,\n        maxBitrate: 0,\n        avgBitrate: 0,\n        decSpecificInfo: {\n            data: new Uint8Array([0x12, 0x10])\n        }\n    };\n    var slConfigDescr = {\n        preDefined: 2\n    };\n    var esDescr = {\n        esID: 0,\n        streamDependenceFlag: 0,\n        urlFlag: 0,\n        ocrStreamFlag: 0,\n        streamPriority: 0,\n        decConfigDescr: decConfigDescr,\n        slConfigDescr: slConfigDescr\n    };\n    var esBox = {\n        esDescr: esDescr\n    };\n    var audioSampleEntry = {\n        type: statics_1.BOX_TYPE_MP4_AUDIO_SAMPLE_ENTRY,\n        dataReferenceIndex: 1,\n        channelCount: aacInfo.channelConfiguration,\n        sampleSize: 16,\n        sampleRate: sampleRate,\n        esBox: esBox\n    };\n    var mp4aBytes = new composer_box_1.MP4AudioSampleEntryBuilder({\n        type: statics_1.BOX_TYPE_MP4_AUDIO_SAMPLE_ENTRY,\n        dataReferenceIndex: 1,\n        channelCount: aacInfo.channelConfiguration,\n        sampleSize: 16,\n        sampleRate: sampleRate,\n        esBox: esBox\n    }).build();\n    var stsdBytes = new composer_box_1.SampleDescriptionBoxBuilder({\n        entryCount: 1,\n        boxes: [audioSampleEntry]\n    }).build();\n    offset += stsdBytes.length;\n    var sttsBytes = new composer_box_1.TimeToSampleBoxBuilder({\n        entryCount: 1,\n        entries: [{ sampleCount: samples.length, sampleDelta: 1024 }]\n    }).build();\n    offset += sttsBytes.length;\n    var stszBytes = new composer_box_1.SampleSizeBoxBuilder({\n        sampleSize: 0,\n        sampleCount: samples.length,\n        sampleSizes: samples.map(sample => sample.byteLength)\n    }).build();\n    offset += stszBytes.length;\n    var mod16 = samples.length % 16;\n    var stscEntryCount = mod16 ? 2 : 1;\n    var stscEntries = [\n        {\n            firstChunk: 1,\n            samplesPerChunk: 16,\n            sampleDescriptionIndex: 1\n        }\n    ];\n    if (stscEntryCount === 2) {\n        stscEntries.push({\n            firstChunk: Math.floor(samples.length / 16) + 1,\n            samplesPerChunk: mod16,\n            sampleDescriptionIndex: 1\n        });\n    }\n    var stscBytes = new composer_box_1.SampleToChunkBoxBuilder({\n        entryCount: stscEntryCount,\n        entries: stscEntries\n    }).build();\n    offset += stscBytes.length;\n    var stcoEntryCount = Math.ceil(samples.length / 16);\n    offset += 4 + stcoEntryCount * 4 + /* header length */ 12;\n    var chunkOffset = offset;\n    var chunkOffsets = [];\n    for (var i = 0, n = samples.length; i < n; ++i) {\n        if (i % 16 === 0)\n            chunkOffsets.push(chunkOffset);\n        chunkOffset += samples[i].byteLength;\n    }\n    var stcoBytes = new composer_box_1.ChunkOffsetBoxBuilder({\n        entryCount: stcoEntryCount,\n        chunkOffsets: chunkOffsets\n    }).build();\n    var stblBytes = new composer_box_1.SampleTableBoxBuilder([\n        stsdBytes,\n        sttsBytes,\n        stszBytes,\n        stscBytes,\n        stcoBytes\n    ]).build();\n    var minfBytes = new composer_box_1.MediaInformationBoxBuilder([\n        smhdBytes,\n        dinfBytes,\n        stblBytes\n    ]).build();\n    var mdiaBytes = new composer_box_1.MediaBoxBuilder([\n        mdhdBytes,\n        hdlrBytes,\n        minfBytes\n    ]).build();\n    var trakBytes = new composer_box_1.TrackBoxBuilder([tkhdBytes, mdiaBytes]).build();\n    var moovBytes = new composer_box_1.MovieBoxBuilder([mvhdBytes, trakBytes]).build();\n    var mdatBytes = new composer_box_1.MediaDataBoxBuilder({\n        data: concatBytes(samples)\n    }).build();\n    return concatBytes([ftypBytes, moovBytes, mdatBytes]);\n};\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/mp4.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/parser.box.js":
/*!******************************************!*\
  !*** ./vendor/mp4.js/dist/parser.box.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataview_1 = __webpack_require__(/*! ./dataview */ \"./vendor/mp4.js/dist/dataview.js\");\nconst parser_descr_1 = __webpack_require__(/*! ./parser.descr */ \"./vendor/mp4.js/dist/parser.descr.js\");\nconst statics_1 = __webpack_require__(/*! ./statics */ \"./vendor/mp4.js/dist/statics.js\");\nconst dict = {};\nfunction Type(type) {\n    return function (constructor) {\n        constructor.TYPE = type;\n        dict[type] = constructor;\n        return constructor;\n    };\n}\nvar getBoxInfo = (bytes, offset = 0) => {\n    var view = new dataview_1.DataView2(bytes, offset);\n    return {\n        byteLength: view.getUint32(0),\n        type: view.getString(4, 4)\n    };\n};\nvar getFullBoxInfo = (bytes, offset = 0) => {\n    var view = new dataview_1.DataView2(bytes, offset);\n    return {\n        byteLength: view.getUint32(0),\n        type: view.getString(4, 4),\n        version: view.getUint8(8),\n        flags: view.getUint24(9)\n    };\n};\nclass BoxParserMixin extends parser_descr_1.DescriptorParserMixin {\n    readBox() {\n        var info = getBoxInfo(this.bytes, this.byteOffset);\n        return exports.createBoxParser(this.readBytes(info.byteLength), info.type).parse();\n    }\n}\nexports.BoxParserMixin = BoxParserMixin;\nclass RootParser extends BoxParserMixin {\n    parse() {\n        var ret = [];\n        while (!this.eof())\n            ret.push(this.readBox());\n        return ret;\n    }\n}\nexports.RootParser = RootParser;\nclass BoxParser extends BoxParserMixin {\n    constructor(bytes) {\n        super(bytes);\n        this.byteLength = this.bytes.length;\n        this.skipBytes(4);\n        this.type = this.readString(4);\n    }\n    parse() {\n        return {\n            byteLength: this.byteLength,\n            type: this.type,\n            bytes: this.bytes\n        };\n    }\n}\nexports.BoxParser = BoxParser;\nclass FullBoxParser extends BoxParser {\n    constructor(bytes) {\n        super(bytes);\n        this.version = this.readUint8();\n        this.flags = this.readUint24();\n    }\n    parse() {\n        var ret = super.parse();\n        ret.version = this.version;\n        ret.flags = this.flags;\n        return ret;\n    }\n}\nexports.FullBoxParser = FullBoxParser;\nlet FileTypeBoxParser = class FileTypeBoxParser extends BoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.majorBrand = this.readString(4);\n        ret.minorVersion = this.readUint32();\n        ret.compatibleBrands = [];\n        while (!this.eof())\n            ret.compatibleBrands.push(this.readString(4));\n        return ret;\n    }\n};\nFileTypeBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_FILE_TYPE_BOX)\n], FileTypeBoxParser);\nexports.FileTypeBoxParser = FileTypeBoxParser;\nclass BoxListParser extends BoxParser {\n    parse() {\n        var ret = super.parse();\n        var boxes = [];\n        while (!this.eof())\n            boxes.push(this.readBox());\n        ret.boxes = boxes;\n        return ret;\n    }\n}\nexports.BoxListParser = BoxListParser;\nlet MovieBoxParser = class MovieBoxParser extends BoxListParser {\n};\nMovieBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MOVIE_BOX)\n], MovieBoxParser);\nexports.MovieBoxParser = MovieBoxParser;\nlet MediaDataBoxParser = class MediaDataBoxParser extends BoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.data = this.bytes.subarray(8);\n        return ret;\n    }\n};\nMediaDataBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MEDIA_DATA_BOX)\n], MediaDataBoxParser);\nexports.MediaDataBoxParser = MediaDataBoxParser;\nlet MovieHeaderBoxParser = class MovieHeaderBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.matrix = [];\n        ret.creationTime = this.readUint32();\n        ret.modificationTime = this.readUint32();\n        ret.timescale = this.readUint32();\n        ret.duration = this.readUint32();\n        ret.rate = this.readUint32();\n        ret.volume = this.readUint16();\n        this.skipBytes(2);\n        this.skipBytes(4 * 2);\n        for (var i = 0; i < 9; ++i)\n            ret.matrix.push(this.readInt32());\n        this.skipBytes(4 * 6);\n        ret.nextTrackID = this.readUint32();\n        return ret;\n    }\n};\nMovieHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MOVIE_HEADER_BOX)\n], MovieHeaderBoxParser);\nexports.MovieHeaderBoxParser = MovieHeaderBoxParser;\nlet TrackBoxParser = class TrackBoxParser extends BoxListParser {\n};\nTrackBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_BOX)\n], TrackBoxParser);\nexports.TrackBoxParser = TrackBoxParser;\nlet TrackHeaderBoxParser = class TrackHeaderBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.matrix = [];\n        ret.creationTime = this.readUint32();\n        ret.modificationTime = this.readUint32();\n        ret.trackID = this.readUint32();\n        this.skipBytes(4);\n        ret.duration = this.readUint32();\n        this.skipBytes(4 * 2);\n        ret.layer = this.readInt16();\n        ret.alternateGroup = this.readInt16();\n        ret.volume = this.readInt16() / 0x100;\n        this.skipBytes(2);\n        for (var i = 0; i < 9; ++i)\n            ret.matrix.push(this.readInt32());\n        ret.width = this.readUint32() / 0x10000;\n        ret.height = this.readUint32() / 0x10000;\n        return ret;\n    }\n};\nTrackHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_HEADER_BOX)\n], TrackHeaderBoxParser);\nexports.TrackHeaderBoxParser = TrackHeaderBoxParser;\nlet TrackReferenceBox = class TrackReferenceBox extends BoxListParser {\n};\nTrackReferenceBox = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_REFERENCE_BOX)\n], TrackReferenceBox);\nexports.TrackReferenceBox = TrackReferenceBox;\nclass TrackReferenceTypeBox extends BoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.trackIDs = [];\n        while (!this.eof())\n            ret.trackIDs.push(this.readUint32());\n        return ret;\n    }\n}\nexports.TrackReferenceTypeBox = TrackReferenceTypeBox;\nlet HintTrackReferenceTypeBox = class HintTrackReferenceTypeBox extends TrackReferenceTypeBox {\n};\nHintTrackReferenceTypeBox = __decorate([\n    Type(statics_1.BOX_TYPE_HINT_TRACK_REFERENCE_TYPE_BOX)\n], HintTrackReferenceTypeBox);\nexports.HintTrackReferenceTypeBox = HintTrackReferenceTypeBox;\nlet DescribeTrackReferenceTypeBox = class DescribeTrackReferenceTypeBox extends TrackReferenceTypeBox {\n};\nDescribeTrackReferenceTypeBox = __decorate([\n    Type(statics_1.BOX_TYPE_DISCRIBE_TRACK_REFERENCE_TYPE_BOX)\n], DescribeTrackReferenceTypeBox);\nexports.DescribeTrackReferenceTypeBox = DescribeTrackReferenceTypeBox;\nlet MediaBoxParser = class MediaBoxParser extends BoxListParser {\n};\nMediaBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MEDIA_BOX)\n], MediaBoxParser);\nexports.MediaBoxParser = MediaBoxParser;\nlet MediaHeaderBoxParser = class MediaHeaderBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.creationTime = this.readUint32();\n        ret.modificationTime = this.readUint32();\n        ret.timescale = this.readUint32();\n        ret.duration = this.readUint32();\n        this.skipBits(1);\n        ret.language = String.fromCharCode.apply(null, [this.readBits(5), this.readBits(5), this.readBits(5)].map(x => x + 0x60));\n        return ret;\n    }\n};\nMediaHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MEDIA_HEADER_BOX)\n], MediaHeaderBoxParser);\nexports.MediaHeaderBoxParser = MediaHeaderBoxParser;\nlet HandlerBoxParser = class HandlerBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        this.skipBytes(4);\n        ret.handlerType = this.readString(4);\n        this.skipBytes(4 * 3);\n        ret.name = this.readUTF8StringNullTerminated();\n        return ret;\n    }\n};\nHandlerBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_HANDLER_BOX)\n], HandlerBoxParser);\nexports.HandlerBoxParser = HandlerBoxParser;\nlet MediaInformationBoxParser = class MediaInformationBoxParser extends BoxListParser {\n};\nMediaInformationBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MEDIA_INFORMATION_BOX)\n], MediaInformationBoxParser);\nexports.MediaInformationBoxParser = MediaInformationBoxParser;\nlet VideoMediaHeaderBoxParser = class VideoMediaHeaderBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var view = new dataview_1.DataView2(this.bytes);\n        ret.opcolor = [];\n        ret.graphicsmode = this.readUint16();\n        for (var i = 0; i < 3; ++i)\n            ret.opcolor.push(this.readUint16());\n        return ret;\n    }\n};\nVideoMediaHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_VIDEO_MEDIA_HEADER_BOX)\n], VideoMediaHeaderBoxParser);\nexports.VideoMediaHeaderBoxParser = VideoMediaHeaderBoxParser;\nlet SoundMediaHeaderBoxParser = class SoundMediaHeaderBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.balance = this.readInt16();\n        return ret;\n    }\n};\nSoundMediaHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SOUND_MEDIA_HEADER_BOX)\n], SoundMediaHeaderBoxParser);\nexports.SoundMediaHeaderBoxParser = SoundMediaHeaderBoxParser;\nlet HintMediaHeaderBoxParser = class HintMediaHeaderBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.maxPDUsize = this.readUint16();\n        ret.avgPDUsize = this.readUint16();\n        ret.maxbitrate = this.readUint32();\n        ret.avgbitrate = this.readUint32();\n        return ret;\n    }\n};\nHintMediaHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_HINT_MEDIA_HEADER_BOX)\n], HintMediaHeaderBoxParser);\nexports.HintMediaHeaderBoxParser = HintMediaHeaderBoxParser;\nlet NullMediaHeaderBoxParser = class NullMediaHeaderBoxParser extends FullBoxParser {\n};\nNullMediaHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_NULL_MEDIA_HEADER_BOX)\n], NullMediaHeaderBoxParser);\nexports.NullMediaHeaderBoxParser = NullMediaHeaderBoxParser;\nlet DataInformationBoxParser = class DataInformationBoxParser extends BoxListParser {\n};\nDataInformationBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_DATA_INFORMATION_BOX)\n], DataInformationBoxParser);\nexports.DataInformationBoxParser = DataInformationBoxParser;\nlet DataReferenceBoxParser = class DataReferenceBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.entryCount = this.readUint32();\n        ret.entries = [];\n        while (!this.eof()) {\n            ret.entries.push(this.readBox());\n        }\n        return ret;\n    }\n};\nDataReferenceBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_DATA_REFERENCE_BOX)\n], DataReferenceBoxParser);\nexports.DataReferenceBoxParser = DataReferenceBoxParser;\nlet DataEntryUrlBoxParser = class DataEntryUrlBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.location = this.readUTF8StringNullTerminated();\n        return ret;\n    }\n};\nDataEntryUrlBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_DATA_ENTRY_URL_BOX)\n], DataEntryUrlBoxParser);\nexports.DataEntryUrlBoxParser = DataEntryUrlBoxParser;\nlet DataEntryUrnBoxParser = class DataEntryUrnBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.name = this.readUTF8StringNullTerminated();\n        ret.location = this.readUTF8StringNullTerminated();\n        return ret;\n    }\n};\nDataEntryUrnBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_DATA_ENTRY_URN_BOX)\n], DataEntryUrnBoxParser);\nexports.DataEntryUrnBoxParser = DataEntryUrnBoxParser;\nlet SampleTableBoxParser = class SampleTableBoxParser extends BoxListParser {\n};\nSampleTableBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_TABLE_BOX)\n], SampleTableBoxParser);\nexports.SampleTableBoxParser = SampleTableBoxParser;\nlet TimeToSampleBoxParser = class TimeToSampleBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.entries = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.entries.push({\n                sampleCount: this.readUint32(),\n                sampleDelta: this.readUint32()\n            });\n        }\n        return ret;\n    }\n};\nTimeToSampleBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_TIME_TO_SAMPLE_BOX)\n], TimeToSampleBoxParser);\nexports.TimeToSampleBoxParser = TimeToSampleBoxParser;\nlet CompositionOffsetBoxParser = class CompositionOffsetBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.entries = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.entries.push({\n                sampleCount: this.readUint32(),\n                sampleOffset: this.readUint32()\n            });\n        }\n        return ret;\n    }\n};\nCompositionOffsetBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_COMPOSITION_OFFSET_BOX)\n], CompositionOffsetBoxParser);\nexports.CompositionOffsetBoxParser = CompositionOffsetBoxParser;\nclass SampleEntryParser extends BoxParser {\n    parse() {\n        var ret = super.parse();\n        this.skipBytes(6);\n        ret.dataReferenceIndex = this.readUint16();\n        return ret;\n    }\n}\nexports.SampleEntryParser = SampleEntryParser;\nclass HintSampleEntryParser extends SampleEntryParser {\n    parse() {\n        var ret = super.parse();\n        ret.data = this.bytes.subarray(16);\n        return ret;\n    }\n}\nexports.HintSampleEntryParser = HintSampleEntryParser;\nclass VisualSampleEntryParser extends SampleEntryParser {\n    parse() {\n        var ret = super.parse();\n        this.skipBytes(16);\n        ret.width = this.readUint16();\n        ret.height = this.readUint16();\n        ret.horizresolution = this.readUint32();\n        ret.vertresolution = this.readUint32();\n        ret.compressorname = this.readString(32);\n        ret.depth = this.readUint16();\n        return ret;\n    }\n}\nexports.VisualSampleEntryParser = VisualSampleEntryParser;\nclass AudioSampleEntryParser extends SampleEntryParser {\n    parse() {\n        var ret = super.parse();\n        this.skipBytes(8);\n        ret.channelCount = this.readUint16();\n        ret.sampleSize = this.readUint16();\n        this.skipBytes(4);\n        ret.sampleRate = this.readUint32() / 0x10000;\n        return ret;\n    }\n}\nexports.AudioSampleEntryParser = AudioSampleEntryParser;\nlet ESDBoxParser = class ESDBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.esDescr = this.readDescriptor();\n        return ret;\n    }\n};\nESDBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_ES_DESCRIPTOR_BOX)\n], ESDBoxParser);\nexports.ESDBoxParser = ESDBoxParser;\nlet MP4VisualSampleEntryParser = class MP4VisualSampleEntryParser extends VisualSampleEntryParser {\n    parse() {\n        var ret = super.parse();\n        ret.esBox = this.readBox();\n        return ret;\n    }\n};\nMP4VisualSampleEntryParser = __decorate([\n    Type(statics_1.BOX_TYPE_MP4_VISUAL_SAMPLE_ENTRY)\n], MP4VisualSampleEntryParser);\nexports.MP4VisualSampleEntryParser = MP4VisualSampleEntryParser;\nlet MP4AudioSampleEntryParser = class MP4AudioSampleEntryParser extends AudioSampleEntryParser {\n    parse() {\n        var ret = super.parse();\n        ret.esBox = this.readBox();\n        return ret;\n    }\n};\nMP4AudioSampleEntryParser = __decorate([\n    Type(statics_1.BOX_TYPE_MP4_AUDIO_SAMPLE_ENTRY)\n], MP4AudioSampleEntryParser);\nexports.MP4AudioSampleEntryParser = MP4AudioSampleEntryParser;\nlet MpegSampleEntryParser = class MpegSampleEntryParser extends SampleEntryParser {\n    parse() {\n        var ret = super.parse();\n        ret.esBox = this.readBox();\n        return ret;\n    }\n};\nMpegSampleEntryParser = __decorate([\n    Type(statics_1.BOX_TYPE_MPEG_SAMPLE_ENTRY)\n], MpegSampleEntryParser);\nexports.MpegSampleEntryParser = MpegSampleEntryParser;\nlet SampleDescriptionBoxParser = class SampleDescriptionBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.boxes = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.boxes.push(this.readBox());\n        }\n        return ret;\n    }\n};\nSampleDescriptionBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_DESCRIPTION_BOX)\n], SampleDescriptionBoxParser);\nexports.SampleDescriptionBoxParser = SampleDescriptionBoxParser;\nlet SampleSizeBoxParser = class SampleSizeBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var sampleSize = this.readUint32();\n        var sampleCount = this.readUint32();\n        if (sampleSize === 0) {\n            ret.sampleSizes = [];\n            for (var i = 0; i < sampleCount; ++i)\n                ret.sampleSizes.push(this.readUint32());\n        }\n        ret.sampleSize = sampleSize;\n        ret.sampleCount = sampleCount;\n        return ret;\n    }\n};\nSampleSizeBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_SIZE_BOX)\n], SampleSizeBoxParser);\nexports.SampleSizeBoxParser = SampleSizeBoxParser;\nlet SampleToChunkBoxParser = class SampleToChunkBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.entries = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.entries.push({\n                firstChunk: this.readUint32(),\n                samplesPerChunk: this.readUint32(),\n                sampleDescriptionIndex: this.readUint32()\n            });\n        }\n        return ret;\n    }\n};\nSampleToChunkBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_TO_CHUNK_BOX)\n], SampleToChunkBoxParser);\nexports.SampleToChunkBoxParser = SampleToChunkBoxParser;\nlet ChunkOffsetBoxParser = class ChunkOffsetBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.chunkOffsets = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.chunkOffsets.push(this.readUint32());\n        }\n        return ret;\n    }\n};\nChunkOffsetBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_CHUNK_OFFSET_BOX)\n], ChunkOffsetBoxParser);\nexports.ChunkOffsetBoxParser = ChunkOffsetBoxParser;\nlet ChunkOffset64BoxParser = class ChunkOffset64BoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.chunkOffsets = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.chunkOffsets.push(this.readUint64());\n        }\n        return ret;\n    }\n};\nChunkOffset64BoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_CHUNK_OFFSET64_BOX)\n], ChunkOffset64BoxParser);\nexports.ChunkOffset64BoxParser = ChunkOffset64BoxParser;\nlet SyncSampleBoxParser = class SyncSampleBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.sampleNumbers = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.sampleNumbers.push(this.readUint32());\n        }\n        return ret;\n    }\n};\nSyncSampleBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SYNC_SAMPLE_BOX)\n], SyncSampleBoxParser);\nexports.SyncSampleBoxParser = SyncSampleBoxParser;\nlet ShadowSyncSampleBoxParser = class ShadowSyncSampleBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.entries = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.entries.push({\n                shadowedSampleNumber: this.readUint32(),\n                syncSampleNumber: this.readUint32()\n            });\n        }\n        return ret;\n    }\n};\nShadowSyncSampleBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SHADOW_SYNC_SAMPLE_BOX)\n], ShadowSyncSampleBoxParser);\nexports.ShadowSyncSampleBoxParser = ShadowSyncSampleBoxParser;\nlet DegradationPriorityBoxParser = class DegradationPriorityBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.priorities = [];\n        while (!this.eof()) {\n            ret.priorities.push(this.readUint16());\n        }\n        return ret;\n    }\n};\nDegradationPriorityBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_DEGRADATION_PRIORITY_BOX)\n], DegradationPriorityBoxParser);\nexports.DegradationPriorityBoxParser = DegradationPriorityBoxParser;\nlet PaddingBitsBoxParser = class PaddingBitsBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var sampleCount = this.readUint32();\n        var pad1;\n        var pad2;\n        ret.sampleCount = sampleCount;\n        ret.samples = [];\n        for (var i = 0; i < sampleCount; ++i) {\n            this.skipBits(1);\n            pad1 = this.readBits(3);\n            this.skipBits(1);\n            pad2 = this.readBits(3);\n            ret.samples.push({\n                pad1: pad1,\n                pad2: pad2\n            });\n        }\n        return ret;\n    }\n};\nPaddingBitsBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_PADDING_BITS_BOX)\n], PaddingBitsBoxParser);\nexports.PaddingBitsBoxParser = PaddingBitsBoxParser;\nlet FreeSpaceBoxParser = class FreeSpaceBoxParser extends MediaBoxParser {\n};\nFreeSpaceBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_FREE_SPACE_BOX)\n], FreeSpaceBoxParser);\nexports.FreeSpaceBoxParser = FreeSpaceBoxParser;\nlet SkipBoxParser = class SkipBoxParser extends MediaBoxParser {\n};\nSkipBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SKIP_BOX)\n], SkipBoxParser);\nexports.SkipBoxParser = SkipBoxParser;\nlet EditBoxParser = class EditBoxParser extends BoxListParser {\n};\nEditBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_EDIT_BOX)\n], EditBoxParser);\nexports.EditBoxParser = EditBoxParser;\nlet EditListBoxParser = class EditListBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.entries = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.entries.push({\n                sagmentDuration: this.readUint32(),\n                mediaTime: this.readUint32(),\n                mediaRateInteger: this.readUint16()\n            });\n            this.skipBytes(2);\n        }\n        return ret;\n    }\n};\nEditListBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_EDIT_LIST_BOX)\n], EditListBoxParser);\nexports.EditListBoxParser = EditListBoxParser;\nlet CopyrightBoxParser = class CopyrightBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        this.skipBits(1);\n        ret.language = String.fromCharCode(this.readBits(5), this.readBits(5), this.readBits(5));\n        ret.notice = this.readUTF8StringNullTerminated();\n        return ret;\n    }\n};\nCopyrightBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_COPYRIGHT_BOX)\n], CopyrightBoxParser);\nexports.CopyrightBoxParser = CopyrightBoxParser;\nlet MovieExtendsBoxParser = class MovieExtendsBoxParser extends BoxListParser {\n};\nMovieExtendsBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MOVIE_EXTENDS_BOX)\n], MovieExtendsBoxParser);\nexports.MovieExtendsBoxParser = MovieExtendsBoxParser;\nlet MovieExtendsHeaderBoxParser = class MovieExtendsHeaderBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.fragmentDuration = this.readUint32();\n        return ret;\n    }\n};\nMovieExtendsHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MOVIE_EXTENDS_HEADER_BOX)\n], MovieExtendsHeaderBoxParser);\nexports.MovieExtendsHeaderBoxParser = MovieExtendsHeaderBoxParser;\nlet TrackExtendsBoxParser = class TrackExtendsBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.trackID = this.readUint32();\n        ret.defaultSampleDescriptionIndex = this.readUint32();\n        ret.defaultSampleDuration = this.readUint32();\n        ret.defaultSampleSize = this.readUint32();\n        ret.defaultSampleFlags = this.readUint32();\n        return ret;\n    }\n};\nTrackExtendsBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_EXTENDS_BOX)\n], TrackExtendsBoxParser);\nexports.TrackExtendsBoxParser = TrackExtendsBoxParser;\nlet MovieFlagmentBoxParser = class MovieFlagmentBoxParser extends BoxListParser {\n};\nMovieFlagmentBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MOVIE_FLAGMENT_BOX)\n], MovieFlagmentBoxParser);\nexports.MovieFlagmentBoxParser = MovieFlagmentBoxParser;\nlet MovieFragmentHeaderBoxParser = class MovieFragmentHeaderBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.sequenceNumber = this.readUint32();\n        return ret;\n    }\n};\nMovieFragmentHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MOVIE_FRAGMENT_HEADER_BOX)\n], MovieFragmentHeaderBoxParser);\nexports.MovieFragmentHeaderBoxParser = MovieFragmentHeaderBoxParser;\nlet TrackFragmentBoxParser = class TrackFragmentBoxParser extends BoxListParser {\n};\nTrackFragmentBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_FRAGMENT_BOX)\n], TrackFragmentBoxParser);\nexports.TrackFragmentBoxParser = TrackFragmentBoxParser;\nlet TrackFragmentHeaderBoxParser = class TrackFragmentHeaderBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.trackID = this.readUint32();\n        if (ret.flags & 0x000001)\n            ret.baseDataOffset = this.readBytes(8);\n        if (ret.flags & 0x000002)\n            ret.sampleDescriptionIndex = this.readUint32();\n        if (ret.flags & 0x000008)\n            ret.defaultSampleDuration = this.readUint32();\n        if (ret.flags & 0x000010)\n            ret.defaultSampleSize = this.readUint32();\n        if (ret.flags & 0x000020)\n            ret.defaultSampleFlags = this.readUint32();\n        return ret;\n    }\n};\nTrackFragmentHeaderBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_FRAGMENT_HEADER_BOX)\n], TrackFragmentHeaderBoxParser);\nexports.TrackFragmentHeaderBoxParser = TrackFragmentHeaderBoxParser;\nlet TrackRunBoxParser = class TrackRunBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var sampleCount = this.readUint32();\n        ret.sampleCount = sampleCount;\n        if (ret.flags & 0x000001)\n            ret.dataOffset = this.readInt32();\n        if (ret.flags & 0x000002)\n            ret.firstSampleFlats = this.readUint32();\n        ret.samples = [];\n        for (var i = 0; i < sampleCount; ++i) {\n            ret.samples.push({\n                sampleDuration: ret.flags & 0x000100 ? this.readUint32() : undefined,\n                sampleSize: ret.flags & 0x000200 ? this.readUint32() : undefined,\n                sampleFlags: ret.flags & 0x000400 ? this.readUint32() : undefined,\n                sampleCompositionTimeOffset: ret.flags & 0x000800 ? this.readUint32() : undefined\n            });\n        }\n        return ret;\n    }\n};\nTrackRunBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_RUN_BOX)\n], TrackRunBoxParser);\nexports.TrackRunBoxParser = TrackRunBoxParser;\nlet TrackFragmentRandomAccessBoxParser = class TrackFragmentRandomAccessBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.trackID = this.readUint32();\n        this.skipBits(26);\n        ret.lengthSizeOfTrafNum = this.readBits(2);\n        ret.lengthSizeOfTrunNum = this.readBits(2);\n        ret.lengthSizeOfSampleNum = this.readBits(2);\n        var numberOfEntry = this.readUint32();\n        ret.numberOfEntry = numberOfEntry;\n        ret.entries = [];\n        for (var i = 0; i < numberOfEntry; ++i) {\n            ret.entries.push({\n                time: this.readUint32(),\n                moofOffset: this.readUint32(),\n                trafNumber: this.readBits((ret.lengthSizeOfTrafNum + 1) * 8),\n                trunNumber: this.readBits((ret.lengthSizeOfTrunNum + 1) * 8),\n                sampleNumber: this.readBits((ret.lengthSizeOfSampleNum + 1) * 8)\n            });\n        }\n        return ret;\n    }\n};\nTrackFragmentRandomAccessBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_TRACK_FRAGMENT_RANDOM_ACCESS_BOX)\n], TrackFragmentRandomAccessBoxParser);\nexports.TrackFragmentRandomAccessBoxParser = TrackFragmentRandomAccessBoxParser;\nlet MovieFragmentRandomAccessOffsetBoxParser = class MovieFragmentRandomAccessOffsetBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.size = this.readUint32();\n        return ret;\n    }\n};\nMovieFragmentRandomAccessOffsetBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_MOVIE_FRAGMENT_RANDOM_ACCESS_OFFSET_BOX)\n], MovieFragmentRandomAccessOffsetBoxParser);\nexports.MovieFragmentRandomAccessOffsetBoxParser = MovieFragmentRandomAccessOffsetBoxParser;\nlet SampleDependencyTypeBoxParser = class SampleDependencyTypeBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.samples = [];\n        while (!this.eof()) {\n            this.skipBits(2);\n            ret.samples.push({\n                sampleDependsOn: this.readBits(2),\n                sampleIsDependedOn: this.readBits(2),\n                sampleHasRedundancy: this.readBits(2)\n            });\n        }\n        return ret;\n    }\n};\nSampleDependencyTypeBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_DEPENDENCY_TYPE_BOX)\n], SampleDependencyTypeBoxParser);\nexports.SampleDependencyTypeBoxParser = SampleDependencyTypeBoxParser;\nlet SampleToGroupBoxParser = class SampleToGroupBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.groupintType = this.readUint32();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.entries = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.entries.push({\n                sampleCount: this.readUint32(),\n                groupDescriptionIndex: this.readUint32()\n            });\n        }\n        return ret;\n    }\n};\nSampleToGroupBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_TO_GROUPE_BOX)\n], SampleToGroupBoxParser);\nexports.SampleToGroupBoxParser = SampleToGroupBoxParser;\nclass SampleGroupDescriptionEntryParser extends BoxParser {\n}\nexports.SampleGroupDescriptionEntryParser = SampleGroupDescriptionEntryParser;\nclass VisualSampleGroupEntryParser extends SampleGroupDescriptionEntryParser {\n}\nexports.VisualSampleGroupEntryParser = VisualSampleGroupEntryParser;\nclass AudioSampleGroupEntryParser extends SampleGroupDescriptionEntryParser {\n}\nexports.AudioSampleGroupEntryParser = AudioSampleGroupEntryParser;\nclass HintSampleGroupEntryParser extends SampleGroupDescriptionEntryParser {\n}\nexports.HintSampleGroupEntryParser = HintSampleGroupEntryParser;\nlet SampleGroupDescriptionBoxParser = class SampleGroupDescriptionBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.groupingType = this.readUint32();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.entries = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.entries.push(this.readBox());\n        }\n        return ret;\n    }\n};\nSampleGroupDescriptionBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_GROUP_DESCRIPTION_BOX)\n], SampleGroupDescriptionBoxParser);\nexports.SampleGroupDescriptionBoxParser = SampleGroupDescriptionBoxParser;\nlet VisualRollRecoveryEntryParser = class VisualRollRecoveryEntryParser extends VisualSampleGroupEntryParser {\n    parse() {\n        var ret = super.parse();\n        ret.rollDistance = this.readInt16();\n        return ret;\n    }\n};\nVisualRollRecoveryEntryParser = __decorate([\n    Type(statics_1.BOX_TYPE_ROLL_RECOVERY_ENTRY)\n], VisualRollRecoveryEntryParser);\nexports.VisualRollRecoveryEntryParser = VisualRollRecoveryEntryParser;\nlet AudioRollRecoveryEntryParser = class AudioRollRecoveryEntryParser extends VisualSampleGroupEntryParser {\n    parse() {\n        var ret = super.parse();\n        ret.rollDistance = this.readInt16();\n        return ret;\n    }\n};\nAudioRollRecoveryEntryParser = __decorate([\n    Type(statics_1.BOX_TYPE_ROLL_RECOVERY_ENTRY)\n], AudioRollRecoveryEntryParser);\nexports.AudioRollRecoveryEntryParser = AudioRollRecoveryEntryParser;\nlet SampleScaleBoxParser = class SampleScaleBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        this.skipBits(7);\n        ret.constraintFlag = this.readBits(1);\n        ret.scaleMethod = this.readUint8();\n        ret.displayCenterX = this.readInt16();\n        ret.displayCenterY = this.readInt16();\n        return ret;\n    }\n};\nSampleScaleBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SAMPLE_SCALE_BOX)\n], SampleScaleBoxParser);\nexports.SampleScaleBoxParser = SampleScaleBoxParser;\nlet SubSampleInformationBoxParser = class SubSampleInformationBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = this.readUint32();\n        ret.entryCount = entryCount;\n        ret.entries = [];\n        for (var i = 0; i < entryCount; ++i) {\n            var sampleDelta = this.readUint32();\n            var subsampleCount = this.readUint16();\n            var samples = [];\n            for (var j = 0; j < subsampleCount; ++j) {\n                samples.push({\n                    subsampleSize: ret.version === 1 ? this.readUint32() : this.readUint16(),\n                    subsamplePriority: this.readUint8(),\n                    discardable: this.readUint8()\n                });\n                this.skipBytes(4);\n            }\n            ret.entries.push({\n                sampleDelta: sampleDelta,\n                subsampleCount: subsampleCount,\n                samples: samples\n            });\n        }\n        return ret;\n    }\n};\nSubSampleInformationBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_SUB_SAMPLE_INFORMATION_BOX)\n], SubSampleInformationBoxParser);\nexports.SubSampleInformationBoxParser = SubSampleInformationBoxParser;\nlet ProgressiveDownloadInfoBoxParser = class ProgressiveDownloadInfoBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.entries = [];\n        while (!this.eof()) {\n            ret.entries.push({\n                rate: this.readUint32(),\n                initialDelay: this.readUint32()\n            });\n        }\n        return ret;\n    }\n};\nProgressiveDownloadInfoBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_PROGRESSIVE_DOWNLOAD_INFO_BOX)\n], ProgressiveDownloadInfoBoxParser);\nexports.ProgressiveDownloadInfoBoxParser = ProgressiveDownloadInfoBoxParser;\nlet MetaBoxParser = class MetaBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.theHandler = this.readBox();\n        ret.otherBoxes = [];\n        while (!this.eof()) {\n            var box = this.readBox();\n            switch (box.type) {\n                case statics_1.BOX_TYPE_PRIMARY_ITEM_BOX:\n                    ret.primaryResource = box;\n                    break;\n                case statics_1.BOX_TYPE_DATA_INFORMATION_BOX:\n                    ret.fileLocations = box;\n                    break;\n                case statics_1.BOX_TYPE_ITEM_LOCATION_BOX:\n                    ret.itemLocations = box;\n                    break;\n                case statics_1.BOX_TYPE_ITEM_INFO_BOX:\n                    ret.itemInfos = box;\n                    break;\n                case statics_1.BOX_TYPE_ITEM_PROTECTION_BOX:\n                    ret.protections = box;\n                    break;\n                case statics_1.BOX_TYPE_IPMP_CONTROL_BOX:\n                    ret.IPMPControl = box;\n                    break;\n                default:\n                    ret.otherBoxes.push(box);\n            }\n        }\n        return ret;\n    }\n};\nMetaBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_META_BOX)\n], MetaBoxParser);\nexports.MetaBoxParser = MetaBoxParser;\nlet XMLBoxParsr = class XMLBoxParsr extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var bytes = this.bytes.subarray(this.byteOffset);\n        ret.xml = dataview_1.DataView2.UTF8BytesToString(bytes);\n        return ret;\n    }\n};\nXMLBoxParsr = __decorate([\n    Type(statics_1.BOX_TYPE_XML_BOX)\n], XMLBoxParsr);\nexports.XMLBoxParsr = XMLBoxParsr;\nlet BinaryXMLBoxParser = class BinaryXMLBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.data = this.bytes.subarray(this.byteOffset);\n        return ret;\n    }\n};\nBinaryXMLBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_BINARY_XML_BOX)\n], BinaryXMLBoxParser);\nexports.BinaryXMLBoxParser = BinaryXMLBoxParser;\nlet ItemLocationBoxParser = class ItemLocationBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.offsetSize = this.readBits(4);\n        ret.lengthSize = this.readBits(4);\n        ret.baseOffsetSize = this.readBits(4);\n        this.skipBits(4);\n        var itemCount = (ret.itemCount = this.readUint16());\n        ret.items = [];\n        for (var i = 0; i < itemCount; ++i) {\n            var itemID = this.readUint16();\n            var dataReferenceIndex = this.readUint16();\n            var baseOffset = this.readBits(ret.baseOffsetSize * 8);\n            var extentCount = this.readUint16();\n            var extents = [];\n            for (var j = 0; j < extentCount; ++j) {\n                extents.push({\n                    extentOffset: this.readBits(ret.offsetSize * 8),\n                    extentLength: this.readBits(ret.lengthSize * 8)\n                });\n            }\n            ret.items.push({\n                itemID: itemID,\n                dataReferenceIndex: dataReferenceIndex,\n                baseOffset: baseOffset,\n                extentCount: extentCount,\n                extents: extents\n            });\n        }\n        return ret;\n    }\n};\nItemLocationBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_ITEM_LOCATION_BOX)\n], ItemLocationBoxParser);\nexports.ItemLocationBoxParser = ItemLocationBoxParser;\nlet PrimaryItemBoxParser = class PrimaryItemBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.itemID = this.readUint16();\n        return ret;\n    }\n};\nPrimaryItemBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_PRIMARY_ITEM_BOX)\n], PrimaryItemBoxParser);\nexports.PrimaryItemBoxParser = PrimaryItemBoxParser;\nlet ItemProtectionBoxParser = class ItemProtectionBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var protectionCount = (ret.protectionCount = this.readUint16());\n        ret.protectionInformations = [];\n        for (var i = 0; i < protectionCount; ++i) {\n            ret.protectionInformations.push(this.readBox());\n        }\n        return ret;\n    }\n};\nItemProtectionBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_ITEM_PROTECTION_BOX)\n], ItemProtectionBoxParser);\nexports.ItemProtectionBoxParser = ItemProtectionBoxParser;\nlet ItemInfoEntryParser = class ItemInfoEntryParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.itemID = this.readUint16();\n        ret.itemProtectionIndex = this.readUint16();\n        ret.itemName = this.readUTF8StringNullTerminated();\n        ret.contentType = this.readUTF8StringNullTerminated();\n        ret.contentEncoding = this.readString();\n        return ret;\n    }\n};\nItemInfoEntryParser = __decorate([\n    Type(statics_1.BOX_TYPE_ITEM_INFO_ENTRY)\n], ItemInfoEntryParser);\nexports.ItemInfoEntryParser = ItemInfoEntryParser;\nlet ItemInfoBoxParser = class ItemInfoBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        var entryCount = (ret.entryCount = this.readUint16());\n        ret.itemInfos = [];\n        for (var i = 0; i < entryCount; ++i) {\n            ret.itemInfos.push(this.readBox());\n        }\n        return ret;\n    }\n};\nItemInfoBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_ITEM_INFO_BOX)\n], ItemInfoBoxParser);\nexports.ItemInfoBoxParser = ItemInfoBoxParser;\nlet ProtectionSchemeInfoBoxParser = class ProtectionSchemeInfoBoxParser extends BoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.originalFormat = this.readBox();\n        while (!this.eof()) {\n            var box = this.readBox();\n            switch (box.type) {\n                case statics_1.BOX_TYPE_IPMP_INFO_BOX:\n                    ret.IPMPDescriptors = box;\n                    break;\n            }\n        }\n        return ret;\n    }\n};\nProtectionSchemeInfoBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_PROTECTION_SCHEME_INFO_BOX)\n], ProtectionSchemeInfoBoxParser);\nexports.ProtectionSchemeInfoBoxParser = ProtectionSchemeInfoBoxParser;\nlet OriginalFormatBoxParser = class OriginalFormatBoxParser extends BoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.dataFormat = this.readString(4);\n        return ret;\n    }\n};\nOriginalFormatBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_ORIGINAL_FORMAT_BOX)\n], OriginalFormatBoxParser);\nexports.OriginalFormatBoxParser = OriginalFormatBoxParser;\nlet IPMPInfoBoxParser = class IPMPInfoBoxParser extends FullBoxParser {\n    parse() {\n        var ret = super.parse();\n        ret.ipmpDescrs = [];\n        while (!this.eof()) {\n            ret.ipmpDescrs.push(this.readDescriptor());\n        }\n        return ret;\n    }\n};\nIPMPInfoBoxParser = __decorate([\n    Type(statics_1.BOX_TYPE_IPMP_INFO_BOX)\n], IPMPInfoBoxParser);\nexports.IPMPInfoBoxParser = IPMPInfoBoxParser;\n/**\n * Create a box parser by the box type.\n * @param bytes\n * @param type A box type.\n */\nexports.createBoxParser = (bytes, type) => {\n    return new (dict[type] || BoxParser)(bytes);\n};\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/parser.box.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/parser.descr.js":
/*!********************************************!*\
  !*** ./vendor/mp4.js/dist/parser.descr.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parser_1 = __webpack_require__(/*! ./parser */ \"./vendor/mp4.js/dist/parser.js\");\nconst statics_1 = __webpack_require__(/*! ./statics */ \"./vendor/mp4.js/dist/statics.js\");\nconst dict = {};\nfunction Tag(tag) {\n    return function (constructor) {\n        constructor.TAG = tag;\n        if (typeof tag === \"number\") {\n            dict[tag] = constructor;\n        }\n        else {\n            tag.forEach(t => (dict[t] = constructor));\n        }\n        return constructor;\n    };\n}\nexports.getDescriptorInfo = (bytes, offset = 0) => {\n    var tag = bytes[offset++];\n    var b = bytes[offset++];\n    var bodyLength = b & 0x7f;\n    var headerLength = 2;\n    while (b & 0x80) {\n        headerLength++;\n        b = bytes[offset++];\n        bodyLength <<= 7;\n        bodyLength |= b & 0x7f;\n    }\n    return {\n        tag: tag,\n        byteLength: headerLength + bodyLength,\n        headerLength: headerLength,\n        bodyLength: bodyLength\n    };\n};\nclass DescriptorParserMixin extends parser_1.BaseParser {\n    readDescriptor() {\n        var info = exports.getDescriptorInfo(this.bytes, this.byteOffset);\n        return exports.createDescriptorParser(this.readBytes(info.byteLength), info.tag).parse();\n    }\n}\nexports.DescriptorParserMixin = DescriptorParserMixin;\nclass DescriptorParser extends DescriptorParserMixin {\n    parse() {\n        var info = exports.getDescriptorInfo(this.bytes);\n        this.skipBytes(info.headerLength);\n        info.bytes = this.bytes;\n        return info;\n    }\n}\nexports.DescriptorParser = DescriptorParser;\nlet DecoderSpecificInfoParser = class DecoderSpecificInfoParser extends DescriptorParser {\n    parse() {\n        var ret = super.parse();\n        ret.data = this.bytes.subarray(this.byteOffset);\n        return ret;\n    }\n};\nDecoderSpecificInfoParser = __decorate([\n    Tag(statics_1.DESCR_TAG_DECODER_SPECIFIC_INFO)\n], DecoderSpecificInfoParser);\nexports.DecoderSpecificInfoParser = DecoderSpecificInfoParser;\nlet ProfileLevelINdicationIndexDescriptor = class ProfileLevelINdicationIndexDescriptor extends DescriptorParser {\n    parse() {\n        var ret = super.parse();\n        ret.profileLevelIndicationIndex = this.readUint8();\n        return ret;\n    }\n};\nProfileLevelINdicationIndexDescriptor = __decorate([\n    Tag(statics_1.DESCR_TAG_PROFILE_LEVEL_INDICATION_INDEX_DESCRIPTOR)\n], ProfileLevelINdicationIndexDescriptor);\nexports.ProfileLevelINdicationIndexDescriptor = ProfileLevelINdicationIndexDescriptor;\nlet DecoderConfigDescriptorParser = class DecoderConfigDescriptorParser extends DescriptorParser {\n    parse() {\n        var ret = super.parse();\n        ret.objectTypeIndication = this.readUint8();\n        ret.streamType = this.readBits(6);\n        ret.upStream = this.readBits(1);\n        this.skipBits(1);\n        ret.bufferSizeDB = this.readUint24();\n        ret.maxBitrate = this.readUint32();\n        ret.avgBitrate = this.readUint32();\n        var info;\n        var descrParser;\n        var descr;\n        ret.profileLevelIndicationIndexDescrs = [];\n        while (!this.eof()) {\n            info = exports.getDescriptorInfo(this.bytes.subarray(this.byteOffset));\n            descrParser = exports.createDescriptorParser(this.readBytes(info.byteLength), info.tag);\n            descr = descrParser.parse();\n            if (descrParser instanceof DecoderSpecificInfoParser) {\n                ret.decSpecificInfo = descr;\n            }\n            else if (descrParser instanceof ProfileLevelINdicationIndexDescriptor) {\n                ret.profileLevelIndicationIndexDescrs.push(descr);\n            }\n            else {\n                throw new TypeError();\n            }\n        }\n        return ret;\n    }\n};\nDecoderConfigDescriptorParser.OBJECT_TYPE_INDICATION = {\n    MP3: 0x6b,\n    AAC: 0x40\n};\nDecoderConfigDescriptorParser = __decorate([\n    Tag(statics_1.DESCR_TAG_DECODER_CONFIG_DESCRIPTOR)\n], DecoderConfigDescriptorParser);\nexports.DecoderConfigDescriptorParser = DecoderConfigDescriptorParser;\nlet SLConfigDescriptorParser = class SLConfigDescriptorParser extends DescriptorParser {\n    parse() {\n        var ret = super.parse();\n        ret.preDefined = this.readUint8();\n        if (ret.preDefined === 0) {\n            ret.useAccessUnitStartFlag = this.readBits(1);\n            ret.useAccessUnitEndFlag = this.readBits(1);\n            ret.useRandomAccessPointFlag = this.readBits(1);\n            ret.hasRandomAccessUnitsOnlyFlag = this.readBits(1);\n            ret.usePaddingFlag = this.readBits(1);\n            ret.useTimeStampsFlag = this.readBits(1);\n            ret.useIdleFlag = this.readBits(1);\n            ret.durationFlag = this.readBits(1);\n            ret.timeStampResolution = this.readUint32();\n            ret.ocrResolution = this.readUint32();\n            ret.timeStampLength = this.readUint8();\n            ret.ocrLength = this.readUint8();\n            ret.auLength = this.readUint8();\n            ret.instantBitrateLength = this.readUint8();\n            ret.degradationPriorityLength = this.readBits(4);\n            ret.auSeqNumLength = this.readBits(5);\n            ret.packetSeqNumLength = this.readBits(5);\n            this.skipBits(2);\n        }\n        if (ret.durationFlag) {\n            ret.timeScale = this.readUint32();\n            ret.accessUnitDuration = this.readUint16();\n            ret.compositionUnitDuration = this.readUint16();\n        }\n        if (ret.useTimeStampsFlag === 0) {\n            ret.startDecodingTimeStamp = this.readBits(ret.timeStampLength);\n            ret.startCompositionTimeStamp = this.readBits(ret.timeStampLength);\n        }\n        return ret;\n    }\n};\nSLConfigDescriptorParser = __decorate([\n    Tag(statics_1.DESCR_TAG_SL_CONFIG_DESCRIPTOR)\n], SLConfigDescriptorParser);\nexports.SLConfigDescriptorParser = SLConfigDescriptorParser;\nclass IPIDescriptorPointerParser extends DescriptorParser {\n}\nexports.IPIDescriptorPointerParser = IPIDescriptorPointerParser;\nclass IPIdentificationDataSetParser extends DescriptorParser {\n}\nexports.IPIdentificationDataSetParser = IPIdentificationDataSetParser;\nclass IPMPDescriptorPointerParser extends DescriptorParser {\n}\nexports.IPMPDescriptorPointerParser = IPMPDescriptorPointerParser;\nclass LanguageDescriptorParser extends DescriptorParser {\n}\nexports.LanguageDescriptorParser = LanguageDescriptorParser;\nclass QosDescriptorParser extends DescriptorParser {\n}\nexports.QosDescriptorParser = QosDescriptorParser;\nclass ExtensionDescriptorParser extends DescriptorParser {\n}\nexports.ExtensionDescriptorParser = ExtensionDescriptorParser;\nlet ESDescriptorParser = class ESDescriptorParser extends DescriptorParser {\n    parse() {\n        var ret = super.parse();\n        var descr;\n        ret.esID = this.readUint16();\n        ret.streamDependenceFlag = this.readBits(1);\n        ret.urlFlag = this.readBits(1);\n        ret.ocrStreamFlag = this.readBits(1);\n        ret.streamPriority = this.readBits(5);\n        if (ret.streamDependenceFlag) {\n            ret.dependsOnEsID = this.readUint16();\n        }\n        if (ret.urlFlag) {\n            ret.urlLength = this.readUint8();\n            ret.urlString = this.readString(ret.urlLength);\n        }\n        if (ret.ocrStreamFlag) {\n            ret.ocrEsID = this.readUint16();\n        }\n        while (!this.eof()) {\n            descr = this.readDescriptor();\n            switch (descr.tag) {\n                case statics_1.DESCR_TAG_DECODER_CONFIG_DESCRIPTOR:\n                    ret.decConfigDescr = descr;\n                    break;\n                case statics_1.DESCR_TAG_SL_CONFIG_DESCRIPTOR:\n                    ret.slConfigDescr = descr;\n                    break;\n            }\n        }\n        return ret;\n    }\n};\nESDescriptorParser = __decorate([\n    Tag(statics_1.DESCR_TAG_ES_DESCRIPTOR)\n], ESDescriptorParser);\nexports.ESDescriptorParser = ESDescriptorParser;\nlet InitialObjectDescriptorParser = class InitialObjectDescriptorParser extends DescriptorParser {\n    parse() {\n        var ret = super.parse();\n        ret.objectDescrID = this.readBits(10);\n        ret.urlFlag = this.readBits(1);\n        ret.includeInlineProfileLevelFlag = this.readBits(1);\n        this.skipBits(4);\n        if (ret.urlFlag) {\n            ret.urlLength = this.readUint8();\n            ret.urlString = this.readString(ret.urlLength);\n        }\n        else {\n            ret.odProfileLevelIndication = this.readUint8();\n            ret.sceneProfileLevelIndication = this.readUint8();\n            ret.audioProfileLevelIndication = this.readUint8();\n            ret.visualProfileLevelIndication = this.readUint8();\n            ret.graphicsProfileLevelIndication = this.readUint8();\n            // TODO\n        }\n        ret.extDescrs = [];\n        if (ret.urlFlag)\n            while (!this.eof()) {\n                ret.extDescrs.push(this.readDescriptor());\n            }\n        return ret;\n    }\n};\nInitialObjectDescriptorParser = __decorate([\n    Tag([0x02, 0x10])\n], InitialObjectDescriptorParser);\nexports.InitialObjectDescriptorParser = InitialObjectDescriptorParser;\nexports.createDescriptorParser = (bytes, tag) => {\n    return new (dict[tag] || DescriptorParser)(bytes);\n};\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/parser.descr.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/parser.js":
/*!**************************************!*\
  !*** ./vendor/mp4.js/dist/parser.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitreader_1 = __webpack_require__(/*! ./bitreader */ \"./vendor/mp4.js/dist/bitreader.js\");\nclass BaseParser extends bitreader_1.BitReader {\n    parse() {\n        throw new Error(\"not implemented error.\");\n    }\n}\nexports.BaseParser = BaseParser;\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/parser.js?");

/***/ }),

/***/ "./vendor/mp4.js/dist/statics.js":
/*!***************************************!*\
  !*** ./vendor/mp4.js/dist/statics.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BOX_TYPE_FILE_TYPE_BOX = \"ftyp\";\nexports.BOX_TYPE_MOVIE_BOX = \"moov\";\nexports.BOX_TYPE_MEDIA_DATA_BOX = \"mdat\";\nexports.BOX_TYPE_MOVIE_HEADER_BOX = \"mvhd\";\nexports.BOX_TYPE_TRACK_BOX = \"trak\";\nexports.BOX_TYPE_TRACK_HEADER_BOX = \"tkhd\";\nexports.BOX_TYPE_TRACK_REFERENCE_BOX = \"tref\";\nexports.BOX_TYPE_HINT_TRACK_REFERENCE_TYPE_BOX = \"hint\";\nexports.BOX_TYPE_DISCRIBE_TRACK_REFERENCE_TYPE_BOX = \"cdsc\";\nexports.BOX_TYPE_MEDIA_BOX = \"mdia\";\nexports.BOX_TYPE_MEDIA_HEADER_BOX = \"mdhd\";\nexports.BOX_TYPE_HANDLER_BOX = \"hdlr\";\nexports.BOX_TYPE_MEDIA_INFORMATION_BOX = \"minf\";\nexports.BOX_TYPE_VIDEO_MEDIA_HEADER_BOX = \"vmhd\";\nexports.BOX_TYPE_SOUND_MEDIA_HEADER_BOX = \"smhd\";\nexports.BOX_TYPE_HINT_MEDIA_HEADER_BOX = \"hmhd\";\nexports.BOX_TYPE_NULL_MEDIA_HEADER_BOX = \"nmhd\";\nexports.BOX_TYPE_DATA_INFORMATION_BOX = \"dinf\";\nexports.BOX_TYPE_DATA_REFERENCE_BOX = \"dref\";\nexports.BOX_TYPE_DATA_ENTRY_URL_BOX = \"url \";\nexports.BOX_TYPE_DATA_ENTRY_URN_BOX = \"urn \";\nexports.BOX_TYPE_SAMPLE_TABLE_BOX = \"stbl\";\nexports.BOX_TYPE_TIME_TO_SAMPLE_BOX = \"stts\";\nexports.BOX_TYPE_COMPOSITION_OFFSET_BOX = \"ctts\";\nexports.BOX_TYPE_ES_DESCRIPTOR_BOX = \"esds\";\nexports.BOX_TYPE_MP4_VISUAL_SAMPLE_ENTRY = \"mp4v\";\nexports.BOX_TYPE_MP4_AUDIO_SAMPLE_ENTRY = \"mp4a\";\nexports.BOX_TYPE_MPEG_SAMPLE_ENTRY = \"mp4s\";\nexports.BOX_TYPE_SAMPLE_DESCRIPTION_BOX = \"stsd\";\nexports.BOX_TYPE_SAMPLE_SIZE_BOX = \"stsz\";\nexports.BOX_TYPE_SAMPLE_TO_CHUNK_BOX = \"stsc\";\nexports.BOX_TYPE_CHUNK_OFFSET_BOX = \"stco\";\nexports.BOX_TYPE_CHUNK_OFFSET64_BOX = \"co64\";\nexports.BOX_TYPE_SYNC_SAMPLE_BOX = \"stss\";\nexports.BOX_TYPE_SHADOW_SYNC_SAMPLE_BOX = \"stsh\";\nexports.BOX_TYPE_DEGRADATION_PRIORITY_BOX = \"stdp\";\nexports.BOX_TYPE_PADDING_BITS_BOX = \"padb\";\nexports.BOX_TYPE_FREE_SPACE_BOX = \"free\";\nexports.BOX_TYPE_SKIP_BOX = \"skip\";\nexports.BOX_TYPE_EDIT_BOX = \"edts\";\nexports.BOX_TYPE_EDIT_LIST_BOX = \"elst\";\nexports.BOX_TYPE_COPYRIGHT_BOX = \"cprt\";\nexports.BOX_TYPE_MOVIE_EXTENDS_BOX = \"mvex\";\nexports.BOX_TYPE_MOVIE_EXTENDS_HEADER_BOX = \"mehd\";\nexports.BOX_TYPE_TRACK_EXTENDS_BOX = \"trex\";\nexports.BOX_TYPE_MOVIE_FLAGMENT_BOX = \"moof\";\nexports.BOX_TYPE_MOVIE_FRAGMENT_HEADER_BOX = \"mfhd\";\nexports.BOX_TYPE_TRACK_FRAGMENT_BOX = \"traf\";\nexports.BOX_TYPE_TRACK_FRAGMENT_HEADER_BOX = \"tfhd\";\nexports.BOX_TYPE_TRACK_RUN_BOX = \"trun\";\nexports.BOX_TYPE_TRACK_FRAGMENT_RANDOM_ACCESS_BOX = \"tfra\";\nexports.BOX_TYPE_MOVIE_FRAGMENT_RANDOM_ACCESS_OFFSET_BOX = \"mfro\";\nexports.BOX_TYPE_SAMPLE_DEPENDENCY_TYPE_BOX = \"sdtp\";\nexports.BOX_TYPE_SAMPLE_TO_GROUPE_BOX = \"sbgp\";\nexports.BOX_TYPE_SAMPLE_GROUP_DESCRIPTION_BOX = \"sgpd\";\nexports.BOX_TYPE_ROLL_RECOVERY_ENTRY = \"roll\";\nexports.BOX_TYPE_SAMPLE_SCALE_BOX = \"stsl\";\nexports.BOX_TYPE_SUB_SAMPLE_INFORMATION_BOX = \"subs\";\nexports.BOX_TYPE_PROGRESSIVE_DOWNLOAD_INFO_BOX = \"pdin\";\nexports.BOX_TYPE_META_BOX = \"meta\";\nexports.BOX_TYPE_XML_BOX = \"xml \";\nexports.BOX_TYPE_BINARY_XML_BOX = \"bxml\";\nexports.BOX_TYPE_ITEM_LOCATION_BOX = \"iloc\";\nexports.BOX_TYPE_PRIMARY_ITEM_BOX = \"pitm\";\nexports.BOX_TYPE_ITEM_PROTECTION_BOX = \"ipro\";\nexports.BOX_TYPE_ITEM_INFO_ENTRY = \"infe\";\nexports.BOX_TYPE_ITEM_INFO_BOX = \"iinf\";\nexports.BOX_TYPE_PROTECTION_SCHEME_INFO_BOX = \"sinf\";\nexports.BOX_TYPE_ORIGINAL_FORMAT_BOX = \"frma\";\nexports.BOX_TYPE_IPMP_INFO_BOX = \"imif\";\nexports.BOX_TYPE_IPMP_CONTROL_BOX = \"impc\";\nexports.DESCR_TAG_ES_DESCRIPTOR = 0x03;\nexports.DESCR_TAG_DECODER_CONFIG_DESCRIPTOR = 0x04;\nexports.DESCR_TAG_DECODER_SPECIFIC_INFO = 0x05;\nexports.DESCR_TAG_SL_CONFIG_DESCRIPTOR = 0x06;\nexports.DESCR_TAG_PROFILE_LEVEL_INDICATION_INDEX_DESCRIPTOR = 0x14;\n\n\n//# sourceURL=webpack:///./vendor/mp4.js/dist/statics.js?");

/***/ })

/******/ });